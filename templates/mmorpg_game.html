<!-- templates/mmorpg_game.html -->
{% extends "layout.html" %}
{% block title %}{{ t.mmorpg_game }}{% endblock %}
{% block content %}
<div class="mmorpg-container">
    <h1>{{ t.mmorpg_game }}</h1>

    <!-- ê²Œì„ UI -->
    <div class="game-ui">
        <div class="player-info">
            <div class="stat">{{ t.level }}: <span id="player-level">{{ player_data.level }}</span></div>
            <div class="stat">{{ t.exp }}: <span id="player-exp">{{ player_data.exp }}</span> / <span id="exp-needed">{{
                    player_data.level * 100 }}</span></div>
            <div class="stat">{{ t.hp }}: <span id="player-hp">{{ player_data.hp }}</span> / 100</div>
            <div class="stat">{{ t.score }}: <span id="player-score">{{ player_data.score }}</span></div>
            <div class="stat">{{ t.tickets }}: <span id="player-tickets">{{ player_data.tickets }}</span> ğŸŸï¸</div>
        </div>

        <div class="game-controls">
            <button id="enter-dungeon" class="dungeon-btn">{{ t.enter_dungeon }} (3 ğŸŸï¸)</button>
            <div class="movement-hint">{{ t.movement_hint }}</div>
        </div>
    </div>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- ì±„íŒ… ì‹œìŠ¤í…œ -->
    <div class="chat-system">
        <div id="chat-messages" class="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="{{ t.chat_placeholder }}" maxlength="100">
            <button id="send-chat">{{ t.send }}</button>
        </div>
    </div>

    <!-- ê²Œì„ ë¡œê·¸ -->
    <div id="game-log" class="game-log"></div>

    <div class="nav-links">
        <a href="{{ url_for('game_room') }}" class="nav-link">{{ t.back_to_game_room }}</a>
    </div>
</div>

<!-- ë ˆë²¨ì—… ëª¨ë‹¬ -->
<div id="levelup-modal" class="modal-overlay hidden">
    <div class="modal-content levelup-content">
        <h2>ğŸ‰ {{ t.level_up }}! ğŸ‰</h2>
        <p>{{ t.level_up_message }} <span id="new-level-display"></span>!</p>
        <button id="close-levelup" class="play-btn">{{ t.continue }}</button>
    </div>
</div>

<!-- ë˜ì „ ì…ì¥ ëª¨ë‹¬ -->
<div id="dungeon-modal" class="modal-overlay hidden">
    <div class="modal-content dungeon-content">
        <h2>ğŸ° {{ t.entering_dungeon }}</h2>
        <p>{{ t.dungeon_desc }}</p>
        <div class="dungeon-reward">{{ t.dungeon_reward }}</div>
        <div class="spinner"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
    // ê²Œì„ ë³€ìˆ˜ë“¤
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const socket = io();

    const playerInfoElements = {
        level: document.getElementById('player-level'),
        exp: document.getElementById('player-exp'),
        expNeeded: document.getElementById('exp-needed'),
        hp: document.getElementById('player-hp'),
        score: document.getElementById('player-score'),
        tickets: document.getElementById('player-tickets')
    };

    let gameState = {
        players: {},
        monsters: {},
        items: {},
        myPlayer: null,
        mySessionId: null
    };

    let keys = {
        w: false, s: false, a: false, d: false,
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        KeyA: false, KeyS: false, KeyD: false, KeyE: false
    };

    // ì•¡ì…˜ ì‹œìŠ¤í…œ
    let playerActions = {
        isDashing: false,
        isBlocking: false,
        isAttacking: false,
        isParrying: false,
        dashCooldown: 0,
        parryCooldown: 0,
        actionState: 'idle' // idle, dashing, blocking, attacking, parrying
    };

    let actionTimers = {
        dash: { duration: 200, cooldown: 800 },
        block: { duration: 0, cooldown: 0 }, // ì§€ì†í˜•
        attack: { duration: 300, cooldown: 500 },
        parry: { duration: 150, cooldown: 1000 }
    };

    // ë²ˆì—­ ë°ì´í„°
    const translations = {{ t | tojson | safe }};

    // ê²Œì„ ì´ˆê¸°í™”
    function initGame() {
        canvas.style.border = '2px solid #5c67f2';
        canvas.style.borderRadius = '8px';
        canvas.style.backgroundColor = '#2d3748';

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                e.preventDefault();

                // ì•¡ì…˜ ì‹¤í–‰
                handleActionInput(e.code);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
                e.preventDefault();

                // Sí‚¤ ë—´ë©´ ë°©ì–´ í•´ì œ
                if (e.code === 'KeyS') {
                    playerActions.isBlocking = false;
                    if (playerActions.actionState === 'blocking') {
                        playerActions.actionState = 'idle';
                    }
                }
            }
        });

        // ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (ëª¬ìŠ¤í„° ê³µê²©, ì•„ì´í…œ ìˆ˜ì§‘)
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // ëª¬ìŠ¤í„° í´ë¦­ ì²´í¬
            for (const [monsterId, monster] of Object.entries(gameState.monsters)) {
                if (isPointInCircle(clickX, clickY, monster.x, monster.y, 25)) {
                    socket.emit('attack_monster', { monster_id: monsterId });
                    addGameLog(`ğŸ—¡ï¸ ${monster.type} ê³µê²©!`, 'attack');
                    return;
                }
            }

            // ì•„ì´í…œ í´ë¦­ ì²´í¬
            for (const [itemId, item] of Object.entries(gameState.items)) {
                if (isPointInCircle(clickX, clickY, item.x, item.y, 20)) {
                    socket.emit('collect_item', { item_id: itemId });
                    return;
                }
            }
        });

        // ì¹´ë©”ë¼ ì‹œìŠ¤í…œ
        let camera = {
            x: 400,
            y: 300,
            targetX: 400,
            targetY: 300,
            smoothing: 0.1
        };

        // 3/4 ë·° ë³€í™˜ í•¨ìˆ˜
        function worldToScreen(worldX, worldY) {
            const isoX = (worldX - worldY) * 0.866; // 3/4 ê°ë„
            const isoY = (worldX + worldY) * 0.5;

            return {
                x: isoX - camera.x + canvas.width / 2,
                y: isoY - camera.y + canvas.height / 2
            };
        }

        // ê³ ê¸‰ ì…ì²´ ìºë¦­í„° ê·¸ë¦¬ê¸°
        function drawIsometric3DCharacter(x, y, color) {
            const time = Date.now() / 1000;

            // ê·¸ë¦¼ì (íƒ€ì›í˜•)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + 30, 18, 8, 0, 0, 2 * Math.PI);
            ctx.fill();

            // ë‹¤ë¦¬ (ì…ì²´ì )
            const legOffset = Math.sin(time * 8) * 2; // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
            drawLeg(x - 6, y + 15, color, legOffset);
            drawLeg(x + 6, y + 15, color, -legOffset);

            // ëª¸ì²´ (ì›í†µí˜•)
            drawCylinder(x, y - 5, 12, 25, color);

            // íŒ” (ì…ì²´ì )
            const armSwing = Math.sin(time * 8) * 0.3;
            drawArm(x - 14, y - 8, color, armSwing);
            drawArm(x + 14, y - 8, color, -armSwing);

            // ë¨¸ë¦¬ (êµ¬ì²´)
            drawSphere(x, y - 22, 10, color);

            // ì•¡ì…˜ ìƒíƒœ í‘œì‹œ (ê¸°ì¡´ ì½”ë“œ)
            drawActionEffects(x, y);
        }

        // ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
        function drawLeg(x, y, color, offset) {
            ctx.fillStyle = darkenColor(color, 20);
            ctx.fillRect(x - 3, y + offset, 6, 18);

            // ë°œ
            ctx.fillStyle = darkenColor(color, 40);
            ctx.fillRect(x - 4, y + 16 + offset, 8, 4);
        }

        // íŒ” ê·¸ë¦¬ê¸°  
        function drawArm(x, y, color, swing) {
            ctx.fillStyle = darkenColor(color, 10);
            ctx.fillRect(x - 3, y + swing * 3, 6, 16);

            // ì†
            ctx.fillStyle = lightenColor(color, 20);
            ctx.beginPath();
            ctx.arc(x, y + 14 + swing * 3, 3, 0, 2 * Math.PI);
            ctx.fill();
        }

        // ì›í†µ ê·¸ë¦¬ê¸° (ëª¸ì²´)
        function drawCylinder(x, y, radius, height, color) {
            // ì˜†ë©´
            ctx.fillStyle = darkenColor(color, 15);
            ctx.fillRect(x - radius, y - height / 2, radius * 2, height);

            // ìœ—ë©´ (íƒ€ì›)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x, y - height / 2, radius, radius * 0.3, 0, 0, 2 * Math.PI);
            ctx.fill();

            // ì•„ë«ë©´
            ctx.fillStyle = darkenColor(color, 30);
            ctx.beginPath();
            ctx.ellipse(x, y + height / 2, radius, radius * 0.3, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        // êµ¬ì²´ ê·¸ë¦¬ê¸° (ë¨¸ë¦¬)
        function drawSphere(x, y, radius, color) {
            // ê·¸ë¼ë””ì–¸íŠ¸ íš¨ê³¼
            const gradient = ctx.createRadialGradient(x - 3, y - 3, 0, x, y, radius);
            gradient.addColorStop(0, lightenColor(color, 30));
            gradient.addColorStop(1, darkenColor(color, 20));

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();

            // ëˆˆ
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 2, 1.5, 0, 2 * Math.PI);
            ctx.arc(x + 3, y - 2, 1.5, 0, 2 * Math.PI);
            ctx.fill();
        }

        // ìƒ‰ìƒ ë°ê²Œ/ì–´ë‘¡ê²Œ í•˜ëŠ” ìœ í‹¸ë¦¬í‹°
        function lightenColor(color, percent) {
            const hex = color.replace('#', '');
            const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + percent);
            const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + percent);
            const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + percent);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function darkenColor(color, percent) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - percent);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - percent);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - percent);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // ì•¡ì…˜ ì´í™íŠ¸ ë¶„ë¦¬
        function drawActionEffects(x, y) {
            if (playerActions.isDashing) {
                // ëŒ€ì‰¬ ì´í™íŠ¸ (ì”ìƒ)
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(x - 15, y - 25, 30, 40);
            }

            if (playerActions.isBlocking) {
                // ë°©ì–´ ì´í™íŠ¸ (ë°©íŒ¨)
                ctx.fillStyle = 'rgba(0, 100, 255, 0.6)';
                drawShield(x - 20, y - 10);
            }

            if (playerActions.isAttacking) {
                // ê³µê²© ì´í™íŠ¸ (ê²€)
                ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                drawSword(x + 12, y - 25);
            }

            if (playerActions.isParrying) {
                // íŒ¨ë§ ì´í™íŠ¸ (ë°˜ì§ì„)
                const sparkles = 8;
                for (let i = 0; i < sparkles; i++) {
                    const angle = (i / sparkles) * Math.PI * 2;
                    const sparkX = x + Math.cos(angle) * 20;
                    const sparkY = y + Math.sin(angle) * 20;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        // ë°©íŒ¨ ê·¸ë¦¬ê¸°
        function drawShield(x, y) {
            ctx.fillRect(x, y, 8, 20);
            ctx.fillStyle = 'rgba(150, 200, 255, 0.8)';
            ctx.fillRect(x + 1, y + 1, 6, 18);
        }

        // ê²€ ê·¸ë¦¬ê¸°
        function drawSword(x, y) {
            // ê²€ë‚ 
            ctx.fillRect(x, y, 3, 20);
            // ê²€ìë£¨
            ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
            ctx.fillRect(x - 1, y + 18, 5, 8);
        }

        // ê²Œì„ ë£¨í”„ ì‹œì‘
        gameLoop();
    }

    // ê²Œì„ ë£¨í”„
    function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
    }

    // ì•¡ì…˜ ì…ë ¥ ì²˜ë¦¬
    function handleActionInput(keyCode) {
        const now = Date.now();

        switch (keyCode) {
            case 'KeyA': // ëŒ€ì‰¬
                if (!playerActions.isDashing && playerActions.dashCooldown < now) {
                    executeDash();
                }
                break;
            case 'KeyS': // ë°©ì–´
                playerActions.isBlocking = true;
                playerActions.actionState = 'blocking';
                break;
            case 'KeyD': // ê³µê²©
                if (!playerActions.isAttacking && playerActions.actionState === 'idle') {
                    executeAttack();
                }
                break;
            case 'KeyE': // íŒ¨ë§
                if (!playerActions.isParrying && playerActions.parryCooldown < now) {
                    executeParry();
                }
                break;
        }
    }

    // ëŒ€ì‰¬ ì‹¤í–‰
    function executeDash() {
        playerActions.isDashing = true;
        playerActions.actionState = 'dashing';
        playerActions.dashCooldown = Date.now() + actionTimers.dash.cooldown;

        setTimeout(() => {
            playerActions.isDashing = false;
            if (playerActions.actionState === 'dashing') {
                playerActions.actionState = 'idle';
            }
        }, actionTimers.dash.duration);

        addGameLog('ğŸ’¨ ëŒ€ì‰¬!', 'action');
    }

    // ê³µê²© ì‹¤í–‰
    function executeAttack() {
        playerActions.isAttacking = true;
        playerActions.actionState = 'attacking';

        setTimeout(() => {
            playerActions.isAttacking = false;
            playerActions.actionState = 'idle';
        }, actionTimers.attack.duration);

        addGameLog('âš”ï¸ ê³µê²©!', 'attack');
    }

    // íŒ¨ë§ ì‹¤í–‰
    function executeParry() {
        playerActions.isParrying = true;
        playerActions.actionState = 'parrying';
        playerActions.parryCooldown = Date.now() + actionTimers.parry.cooldown;

        setTimeout(() => {
            playerActions.isParrying = false;
            if (playerActions.actionState === 'parrying') {
                playerActions.actionState = 'idle';
            }
        }, actionTimers.parry.duration);

        addGameLog('ğŸ›¡ï¸ íŒ¨ë§!', 'action');
    }

    // ê²Œì„ ì—…ë°ì´íŠ¸
    function update() {
        if (!gameState.myPlayer) return;

        let moved = false;
        let moveSpeed = 3;
        if (playerActions.isDashing) {
            moveSpeed = 8; // ëŒ€ì‰¬ ì¤‘ì—ëŠ” ì´ë™ ì†ë„ ì¦ê°€
        } else if (playerActions.isBlocking) {
            moveSpeed = 1; // ë°©ì–´ ì¤‘ì—ëŠ” ì´ë™ ì†ë„ ê°ì†Œ
        } else if (playerActions.isAttacking || playerActions.isParrying) {
            moveSpeed = 0.5; // ê³µê²© ë˜ëŠ” íŒ¨ë§ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
        }


        // ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ ë”°ë¼ê°€ê¸° (ë¶€ë“œëŸ½ê²Œ)
        if (gameState.myPlayer) {
            camera.targetX = gameState.myPlayer.x;
            camera.targetY = gameState.myPlayer.y;

            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;
        }
        let newX = gameState.myPlayer.x;
        let newY = gameState.myPlayer.y;

        // ì´ë™ ì²˜ë¦¬
        if (keys['KeyW'] || keys['ArrowUp']) {
            newY = Math.max(25, newY - moveSpeed);
            moved = true;
        }
        if (keys['KeyS'] || keys['ArrowDown']) {
            newY = Math.min(canvas.height - 25, newY + moveSpeed);
            moved = true;
        }
        if (keys['KeyA'] || keys['ArrowLeft']) {
            newX = Math.max(25, newX - moveSpeed);
            moved = true;
        }
        if (keys['KeyD'] || keys['ArrowRight']) {
            newX = Math.min(canvas.width - 25, newX + moveSpeed);
            moved = true;
        }

        if (moved) {
            gameState.myPlayer.x = newX;
            gameState.myPlayer.y = newY;
            socket.emit('player_move', { x: newX, y: newY });
        }
    }

    // ë Œë”ë§
    function render() {
        // í™”ë©´ í´ë¦¬ì–´
        ctx.fillStyle = '#2d3748';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ê²©ì ê·¸ë¦¬ê¸°
        drawGrid();

        // ì•„ì´í…œ ë Œë”ë§
        for (const [itemId, item] of Object.entries(gameState.items)) {
            drawItem(item);
        }

        // ëª¬ìŠ¤í„° ë Œë”ë§
        for (const [monsterId, monster] of Object.entries(gameState.monsters)) {
            drawMonster(monster);
        }

        // í”Œë ˆì´ì–´ë“¤ ë Œë”ë§
        for (const [sessionId, player] of Object.entries(gameState.players)) {
            drawPlayer(player, sessionId === gameState.mySessionId);
        }
    }

    // ê²©ì ê·¸ë¦¬ê¸°
    function drawGrid() {
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 0.5;

        for (let x = 0; x < canvas.width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        for (let y = 0; y < canvas.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }

    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° (3/4 ë·°)
    function drawPlayer(player, isMe) {
        const screenX = worldToScreen(player.x, player.y).x;
        const screenY = worldToScreen(player.x, player.y).y;

        // ìºë¦­í„° ëª¸ì²´ (ì…ì²´ íš¨ê³¼)
        ctx.fillStyle = isMe ? '#4CAF50' : '#2196F3';
        drawIsometric3DCharacter(screenX, screenY, isMe ? '#4CAF50' : '#2196F3');

        // í”Œë ˆì´ì–´ ì´ë¦„
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(player.username, screenX, screenY - 25);

        // ë ˆë²¨ í‘œì‹œ
        ctx.fillText(`Lv.${player.level}`, screenX, screenY + 35);

        // HP ë°”
        const barWidth = 30;
        const barHeight = 4;
        const hpPercent = player.hp / 100;

        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenX - barWidth / 2, screenY + 25, barWidth, barHeight);
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(screenX - barWidth / 2, screenY + 25, barWidth * hpPercent, barHeight);
    }

    // ëª¬ìŠ¤í„° ê·¸ë¦¬ê¸° (3/4 ë·°)
    function drawMonster(monster) {
        const screenPos = worldToScreen(monster.x, monster.y);

        // ëª¬ìŠ¤í„° ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(screenPos.x - 20, screenPos.y + 25, 40, 10);

        // ëª¬ìŠ¤í„° ë³¸ì²´ (ì…ì²´)
        ctx.font = '35px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(monster.type, screenPos.x, screenPos.y);

        // HP ë°”
        const barWidth = 40;
        const barHeight = 6;
        const hpPercent = monster.hp / monster.max_hp;

        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - 25, barWidth, barHeight);
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - 25, barWidth * hpPercent, barHeight);

        // HP í…ìŠ¤íŠ¸
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '10px Arial';
        ctx.fillText(`${monster.hp}/${monster.max_hp}`, screenPos.x, screenPos.y - 30);
    }


    function drawItem(item) {
        const screenPos = worldToScreen(item.x, item.y);

        ctx.font = '25px Arial';
        ctx.textAlign = 'center';

        // ë°˜ì§ì´ëŠ” íš¨ê³¼
        const time = Date.now() / 1000;
        const alpha = 0.7 + 0.3 * Math.sin(time * 3);
        const bounce = Math.sin(time * 4) * 3; // ìœ„ì•„ë˜ í”ë“¤ë¦¼

        ctx.globalAlpha = alpha;
        ctx.fillText(item.type, screenPos.x, screenPos.y + bounce);

        ctx.globalAlpha = 1;
    }

    // ì ê³¼ ì›ì˜ ì¶©ëŒ ì²´í¬
    function isPointInCircle(px, py, cx, cy, radius) {
        const dx = px - cx;
        const dy = py - cy;
        return (dx * dx + dy * dy) <= (radius * radius);
    }

    // ê²Œì„ ë¡œê·¸ ì¶”ê°€
    function addGameLog(message, type = 'info') {
        const gameLog = document.getElementById('game-log');
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${type}`;
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

        gameLog.appendChild(logEntry);
        gameLog.scrollTop = gameLog.scrollHeight;

        // ìµœëŒ€ 50ê°œ ë¡œê·¸ë§Œ ìœ ì§€
        while (gameLog.children.length > 50) {
            gameLog.removeChild(gameLog.firstChild);
        }
    }

    // ì±„íŒ… ë©”ì‹œì§€ ì¶”ê°€
    function addChatMessage(username, message) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';
        messageDiv.innerHTML = `<strong>${username}:</strong> ${message}`;

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // ìµœëŒ€ 100ê°œ ë©”ì‹œì§€ë§Œ ìœ ì§€
        while (chatMessages.children.length > 100) {
            chatMessages.removeChild(chatMessages.firstChild);
        }
    }

    // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
    function updatePlayerInfo(data) {
        if (data.level) playerInfoElements.level.textContent = data.level;
        if (data.exp !== undefined) {
            playerInfoElements.exp.textContent = data.exp;
            playerInfoElements.expNeeded.textContent = data.level * 100;
        }
        if (data.hp) playerInfoElements.hp.textContent = data.hp;
        if (data.score) playerInfoElements.score.textContent = data.score;
        if (data.tickets) playerInfoElements.tickets.textContent = data.tickets;
    }

    // Socket.IO ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
    socket.on('connect', () => {
        addGameLog('ğŸŒ ê²Œì„ ì„œë²„ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
        gameState.mySessionId = socket.id;
    });

    socket.on('game_state', (data) => {
        gameState.players = data.players;
        gameState.monsters = data.monsters;
        gameState.items = data.items;

        if (gameState.mySessionId && data.players[gameState.mySessionId]) {
            gameState.myPlayer = data.players[gameState.mySessionId];
        }

        addGameLog(`ğŸ® ê²Œì„ ìƒíƒœ ë¡œë“œë¨ - í”Œë ˆì´ì–´: ${Object.keys(data.players).length}, ëª¬ìŠ¤í„°: ${Object.keys(data.monsters).length}`, 'info');
    });

    socket.on('player_joined', (data) => {
        gameState.players[data.session_id] = data.player;
        addGameLog(`ğŸ‘‹ ${data.player.username}ë‹˜ì´ ê²Œì„ì— ì°¸ì—¬í–ˆìŠµë‹ˆë‹¤!`, 'join');
    });

    socket.on('player_left', (data) => {
        if (gameState.players[data.session_id]) {
            addGameLog(`ğŸ‘‹ ${gameState.players[data.session_id].username}ë‹˜ì´ ê²Œì„ì„ ë– ë‚¬ìŠµë‹ˆë‹¤.`, 'leave');
            delete gameState.players[data.session_id];
        }
    });

    socket.on('player_moved', (data) => {
        if (gameState.players[data.session_id]) {
            gameState.players[data.session_id].x = data.x;
            gameState.players[data.session_id].y = data.y;
        }
    });

    socket.on('monster_damaged', (data) => {
        if (gameState.monsters[data.monster_id]) {
            gameState.monsters[data.monster_id].hp = data.hp;
            addGameLog(`ğŸ’¥ ëª¬ìŠ¤í„°ê°€ ${data.damage} ë°ë¯¸ì§€ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤!`, 'combat');
        }
    });

    socket.on('monster_killed', (data) => {
        delete gameState.monsters[data.monster_id];
        addGameLog(`âš”ï¸ ${data.killer}ë‹˜ì´ ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤! (+${data.exp_gained} EXP, +${data.score_gained} ì ìˆ˜)`, 'success');

        if (data.killer === "{{ session.username }}") {
            // ë‚´ê°€ ì²˜ì¹˜í•œ ê²½ìš° UI ì—…ë°ì´íŠ¸
            const currentScore = parseInt(playerInfoElements.score.textContent);
            playerInfoElements.score.textContent = currentScore + data.score_gained;
        }
    });

    socket.on('item_collected', (data) => {
        delete gameState.items[data.item_id];
        addGameLog(`âœ¨ ${data.collector}ë‹˜ì´ ${data.item_type} ì•„ì´í…œì„ íšë“í–ˆìŠµë‹ˆë‹¤! (+${data.score_bonus} ì ìˆ˜)`, 'success');

        if (data.collector === "{{ session.username }}") {
            // ë‚´ê°€ íšë“í•œ ê²½ìš° UI ì—…ë°ì´íŠ¸
            const currentScore = parseInt(playerInfoElements.score.textContent);
            playerInfoElements.score.textContent = currentScore + data.score_bonus;
        }
    });

    socket.on('level_up', (data) => {
        const modal = document.getElementById('levelup-modal');
        const newLevelDisplay = document.getElementById('new-level-display');

        newLevelDisplay.textContent = data.new_level;
        modal.classList.remove('hidden');

        updatePlayerInfo({
            level: data.new_level,
            exp: 0,
            hp: 100
        });

        addGameLog(`ğŸ‰ ë ˆë²¨ì—…! ë ˆë²¨ ${data.new_level}ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
    });

    socket.on('chat_message', (data) => {
        addChatMessage(data.username, data.message);
    });

    socket.on('disconnect', () => {
        addGameLog('âŒ ì„œë²„ì™€ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.', 'error');
    });

    // UI ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
    document.getElementById('close-levelup').addEventListener('click', () => {
        document.getElementById('levelup-modal').classList.add('hidden');
    });

    document.getElementById('send-chat').addEventListener('click', () => {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();

        if (message) {
            socket.emit('chat_message', { message: message });
            chatInput.value = '';
        }
    });

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('send-chat').click();
        }
    });

    document.getElementById('enter-dungeon').addEventListener('click', () => {
        const tickets = parseInt(playerInfoElements.tickets.textContent);
        if (tickets >= 3) {
            // ë˜ì „ ì…ì¥ ë¡œì§ (í–¥í›„ êµ¬í˜„)
            const modal = document.getElementById('dungeon-modal');
            modal.classList.remove('hidden');

            setTimeout(() => {
                modal.classList.add('hidden');
                addGameLog('ğŸ° ë˜ì „ ê¸°ëŠ¥ì€ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', 'info');
            }, 3000);
        } else {
            addGameLog('âŒ ë˜ì „ ì…ì¥ì—ëŠ” í‹°ì¼“ 3ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤!', 'error');
        }
    });

    // ê²Œì„ ì‹œì‘
    window.addEventListener('load', initGame);
</script>
{% endblock %}