<!-- templates/mmorpg_game.html -->
{% extends "layout.html" %}
{% block title %}{{ t.mmorpg_game }}{% endblock %}
{% block content %}
<div class="mmorpg-container">
    <h1>{{ t.mmorpg_game }}</h1>

    <!-- ê²Œì„ UI -->
    <div class="game-ui">
        <div class="player-info">
            <div class="stat">{{ t.level }}: <span id="player-level">{{ player_data.level }}</span></div>
            <div class="stat">{{ t.exp }}: <span id="player-exp">{{ player_data.exp }}</span> / <span id="exp-needed">{{
                    player_data.level * 100 }}</span></div>
            <div class="stat">{{ t.hp }}: <span id="player-hp">{{ player_data.hp }}</span> / 100</div>
            <div class="stat">{{ t.score }}: <span id="player-score">{{ player_data.score }}</span></div>
            <div class="stat">{{ t.tickets }}: <span id="player-tickets">{{ player_data.tickets }}</span> ğŸŸï¸</div>
        </div>

        <div class="game-controls">
            <button id="enter-dungeon" class="dungeon-btn">{{ t.enter_dungeon }} (3 ğŸŸï¸)</button>
            <div class="duel-controls">
                <input type="text" id="duel-target" placeholder="í”Œë ˆì´ì–´ ì´ë¦„" maxlength="20">
                <button id="request-duel" class="duel-btn">ë“€ì–¼ ì‹ ì²­</button>
            </div>
            <div class="movement-hint">ë°©í–¥í‚¤:ì´ë™, A:ëŒ€ì‰¬, S:ë°©ì–´, D:ê³µê²©, E:íŒ¨ë§, Z:íŒŒë°</div>
        </div>
    </div>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- ì±„íŒ… ì‹œìŠ¤í…œ -->
    <div class="chat-system">
        <div id="chat-messages" class="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="{{ t.chat_placeholder }}" maxlength="100">
            <button id="send-chat">{{ t.send }}</button>
        </div>
    </div>

    <!-- ê²Œì„ ë¡œê·¸ -->
    <div id="game-log" class="game-log"></div>

    <div class="nav-links">
        <a href="{{ url_for('game_room') }}" class="nav-link">{{ t.back_to_game_room }}</a>
    </div>
</div>

<!-- ë ˆë²¨ì—… ëª¨ë‹¬ -->
<div id="levelup-modal" class="modal-overlay hidden">
    <div class="modal-content levelup-content">
        <h2>ğŸ‰ {{ t.level_up }}! ğŸ‰</h2>
        <p>{{ t.level_up_message }} <span id="new-level-display"></span>!</p>
        <button id="close-levelup" class="play-btn">{{ t.continue }}</button>
    </div>
</div>

<!-- ë˜ì „ ì…ì¥ ëª¨ë‹¬ -->
<div id="dungeon-modal" class="modal-overlay hidden">
    <div class="modal-content dungeon-content">
        <h2>ğŸ° {{ t.entering_dungeon }}</h2>
        <p>{{ t.dungeon_desc }}</p>
        <div class="dungeon-reward">{{ t.dungeon_reward }}</div>
        <div class="spinner"></div>
    </div>
</div>

<!-- ë“€ì–¼ ìš”ì²­ ëª¨ë‹¬ -->
<div id="duel-request-modal" class="modal-overlay hidden">
    <div class="modal-content duel-content">
        <h2>âš”ï¸ ë“€ì–¼ ì‹ ì²­</h2>
        <p id="duel-request-message"></p>
        <div class="duel-buttons">
            <button id="accept-duel" class="accept-btn">ìˆ˜ë½</button>
            <button id="decline-duel" class="decline-btn">ê±°ì ˆ</button>
        </div>
    </div>
</div>

<!-- ë“€ì–¼ ì•Œë¦¼ ëª¨ë‹¬ -->
<div id="duel-notification-modal" class="modal-overlay hidden">
    <div class="modal-content duel-notification-content">
        <h2 id="duel-notification-title">âš”ï¸ ë“€ì–¼</h2>
        <p id="duel-notification-message"></p>
        <button id="close-duel-notification" class="play-btn">í™•ì¸</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
    // ê²Œì„ ë³€ìˆ˜ë“¤
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const socket = io();

    const playerInfoElements = {
        level: document.getElementById('player-level'),
        exp: document.getElementById('player-exp'),
        expNeeded: document.getElementById('exp-needed'),
        hp: document.getElementById('player-hp'),
        score: document.getElementById('player-score'),
        tickets: document.getElementById('player-tickets')
    };

    let gameState = {
        players: {},
        monsters: {},
        items: {},
        duels: {},
        duel_requests: {},
        myPlayer: null,
        mySessionId: null,
        currentDuelRequestId: null,
        playerDirection: 'down' // í”Œë ˆì´ì–´ê°€ ë³´ê³  ìˆëŠ” ë°©í–¥ (up, down, left, right)
    };

    let keys = {
        w: false, s: false, a: false, d: false,
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        KeyA: false, KeyS: false, KeyD: false, KeyE: false, KeyZ: false, KeyQ: false
    };

    // ì•¡ì…˜ ì‹œìŠ¤í…œ
    let playerActions = {
        isDashing: false,
        isBlocking: false,
        isAttacking: false,
        isParrying: false,
        isWeaponDrawn: true, // ë¬´ê¸°ê°€ êº¼ë‚´ì ¸ ìˆëŠ”ì§€
        isDrawingWeapon: false, // ë¬´ê¸°ë¥¼ êº¼ë‚´ëŠ” ì¤‘ì¸ì§€
        isSheathingWeapon: false, // ë¬´ê¸°ë¥¼ ì§‘ì–´ë„£ëŠ” ì¤‘ì¸ì§€
        attackSwingAngle: 0, // ê²€ íœ˜ë‘ë¥´ê¸° ê°ë„
        weaponDrawProgress: 0, // ë¬´ê¸° êº¼ë‚´ê¸°/ì§‘ì–´ë„£ê¸° ì§„í–‰ë„ (0-1)
        dashCooldown: 0,
        parryCooldown: 0,
        weaponToggleCooldown: 0,
        actionState: 'idle' // idle, dashing, blocking, attacking, parrying
    };

    let actionTimers = {
        dash: { duration: 200, cooldown: 800 },
        block: { duration: 0, cooldown: 0 }, // ì§€ì†í˜•
        attack: { duration: 300, cooldown: 500 },
        parry: { duration: 150, cooldown: 1000 }
    };

    // ì¹´ë©”ë¼ ì‹œìŠ¤í…œ (ì „ì—­ìœ¼ë¡œ ì´ë™)
    let camera = {
        x: 0,
        y: 0,
        targetX: 0,
        targetY: 0,
        smoothing: 0.1
    };

    // ë°ë¯¸ì§€ ìˆ«ì ì‹œìŠ¤í…œ
    let damageNumbers = [];
    // í™”ë©´ íš¨ê³¼(ì¹´ë©”ë¼ ì…°ì´í¬/íˆíŠ¸ìŠ¤í†±)
    let effects = {
        cameraShake: { amp: 0, duration: 0, start: 0, decay: 0.85 },
        hitstopUntil: 0
    };
    // ì† ê¸°ì¤€ì (ë¬´ê¸° ê·¸ë¦¬ê¸°ìš©) â€” ì´ˆê¸°ê°’ì€ í”Œë ˆì´ì–´ ì¤‘ì‹¬
    let handAnchor = { x: canvas.width/2, y: canvas.height/2, angle: 0, dir: 'down' };

    // ìˆ² ë°°ê²½ ë ˆì´ì–´ ë°ì´í„°
    const forest = {
        far: [],
        mid: [],
        leaves: []
    };

    // ë²ˆì—­ ë°ì´í„°
    const translations = {{ t | tojson | safe }};

    // ì „ì—­ í•¨ìˆ˜ë“¤
    function worldToScreen(worldX, worldY) {
        return {
            x: worldX - camera.x + canvas.width / 2,
            y: worldY - camera.y + canvas.height / 2
        };
    }

    function drawIsometric3DCharacter(x, y, color, isMoving = false, direction = 'down') {
        // ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
        const time = Date.now() / 1000;
        const walkCycle = Math.sin(time * 8) * (isMoving ? 1 : 0);
        
        // ê³µí†µ ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.save();
        ctx.scale(1, 0.3);
        ctx.beginPath();
        ctx.arc(x, (y + 35) / 0.3, 20, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        
        // ë°©í–¥ì— ë”°ë¼ ë‹¤ë¥¸ ìºë¦­í„° ê·¸ë¦¬ê¸°
        if (direction === 'down') {
            drawCharacterFront(x, y, color, walkCycle);
        } else if (direction === 'up') {
            drawCharacterBack(x, y, color, walkCycle);
        } else if (direction === 'left') {
            drawCharacterLeft(x, y, color, walkCycle);
        } else if (direction === 'right') {
            drawCharacterRight(x, y, color, walkCycle);
        }
        
        // ê¸°ë³¸ ë¬´ê¸° (í•œì†ê²€) í‘œì‹œ (ë°©í–¥ì— ë”°ë¼ ìœ„ì¹˜ ì¡°ì •)
        drawWeapon(x, y, direction);

        // ì•¡ì…˜ ìƒíƒœ í‘œì‹œ
        drawActionEffects(x, y);
    }
    
    // ì •ë©´ (ì•„ë˜ìª½ ë³´ê¸°) - 3D ì¡¸ë¼ë§¨ ìŠ¤íƒ€ì¼
    function drawCharacterFront(x, y, color, walkCycle) {
        const time = Date.now() / 1000;
        
        // ìì—°ìŠ¤ëŸ¬ìš´ ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ê³„ì‚°
        const leftLegAngle = Math.sin(time * 6) * 25; // ì™¼ìª½ ë‹¤ë¦¬
        const rightLegAngle = Math.sin(time * 6 + Math.PI) * 25; // ì˜¤ë¥¸ìª½ ë‹¤ë¦¬ (ë°˜ëŒ€)
        const leftArmAngle = Math.sin(time * 6 + Math.PI) * 15; // ì™¼íŒ” (ë‹¤ë¦¬ì™€ ë°˜ëŒ€)
        const rightArmAngle = Math.sin(time * 6) * 15; // ì˜¤ë¥¸íŒ”
        const bodyBob = Math.abs(Math.sin(time * 12)) * 2; // ëª¸í†µ ìƒí•˜ ì›€ì§ì„
        
        // ì›€ì§ì„ ì ìš© (ê±¸ì„ ë•Œë§Œ)
        const moveMultiplier = walkCycle !== 0 ? 1 : 0;
        
        ctx.save();
        
        // === ë‹¤ë¦¬ (íƒ€ì›í˜• ì›í†µ) ===
        // ì™¼ìª½ ë‹¤ë¦¬
        ctx.save();
        ctx.translate(x - 6, y + 15);
        ctx.rotate((leftLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 6, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        // ì˜¤ë¥¸ìª½ ë‹¤ë¦¬
        ctx.save();
        ctx.translate(x + 6, y + 15);
        ctx.rotate((rightLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 6, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ëª¸í†µ (3D íƒ€ì›í˜•) ===
        drawTorso3D(x, y - 2 - bodyBob * moveMultiplier, color);
        
        // === íŒ” (íƒ€ì›í˜• ì›í†µ) ===
        // ì™¼ìª½ íŒ”
        ctx.save();
        ctx.translate(x - 15, y - 8);
        ctx.rotate((leftArmAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 18, color, 'vertical');
        ctx.restore();
        
        // ì˜¤ë¥¸ìª½ íŒ”
        const rightRad = (rightArmAngle * moveMultiplier * Math.PI) / 180;
        ctx.save();
        ctx.translate(x + 15, y - 8);
        ctx.rotate(rightRad);
        drawLimb3D(0, 0, 5, 18, color, 'vertical');
        ctx.restore();

        // ì† ìœ„ì¹˜ ì¶”ì •(ì •ë©´ ë³´ê¸°, ì˜¤ë¥¸ì† ê¸°ì¤€)
        handAnchor.x = x + 15 + Math.sin(rightRad) * 18;
        handAnchor.y = y - 8 + Math.cos(rightRad) * 18;
        handAnchor.angle = rightRad;
        handAnchor.dir = 'down';
        
        // === ë¨¸ë¦¬ (3D íƒ€ì›í˜•) ===
        drawHead3D(x, y - 22 - bodyBob * moveMultiplier, getLighterColor(color));
        
        // === ì–¼êµ´ ===
        const headY = y - 22 - bodyBob * moveMultiplier;
        drawFace(x, headY, 'front');
        
        ctx.restore();
    }
    
    // ë¶€ë“œëŸ¬ìš´ ëª¸í†µ ê·¸ë¦¬ê¸°
    function drawTorso3D(x, y, color) {
        // ëª¸í†µ ë©”ì¸ (íƒ€ì›í˜•ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ)
        const gradient = ctx.createRadialGradient(x - 2, y, 0, x, y, 20);
        gradient.addColorStop(0, getLighterColor(color));
        gradient.addColorStop(0.6, color);
        gradient.addColorStop(1, getDarkerColor(color));
        
        ctx.fillStyle = gradient;
        // ìƒì²´ (ë” ë„“ê²Œ)
        ctx.beginPath();
        ctx.ellipse(x, y - 10, 14, 18, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // í•˜ì²´ (ë” ì¢ê²Œ)
        ctx.beginPath();
        ctx.ellipse(x, y + 15, 10, 15, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // ìì—°ìŠ¤ëŸ¬ìš´ ì—°ê²°ì„ ìœ„í•œ ì¤‘ê°„ ë¶€ë¶„
        ctx.beginPath();
        ctx.ellipse(x, y + 2, 12, 16, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ë¶€ë“œëŸ¬ìš´ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
    function drawHead3D(x, y, color) {
        const gradient = ctx.createRadialGradient(x - 2, y, 0, x, y, 15);
        gradient.addColorStop(0, getLighterColor(color));
        gradient.addColorStop(0.7, color);
        gradient.addColorStop(1, getDarkerColor(color));
        
        ctx.fillStyle = gradient;
        
        // ë¨¸ë¦¬ (íƒ€ì›í˜•)
        ctx.beginPath();
        ctx.ellipse(x, y, 10, 13, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // ëª© ë¶€ë¶„ (ìì—°ìŠ¤ëŸ¬ìš´ ì—°ê²°)
        ctx.beginPath();
        ctx.ellipse(x, y + 10, 6, 8, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ë¶€ë“œëŸ¬ìš´ íŒ”ë‹¤ë¦¬ ê·¸ë¦¬ê¸°
    function drawLimb3D(x, y, width, height, color, direction) {
        if (direction === 'vertical') {
            const gradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
            gradient.addColorStop(0, getDarkerColor(color));
            gradient.addColorStop(0.3, color);
            gradient.addColorStop(0.7, getLighterColor(color));
            gradient.addColorStop(1, color);
            
            ctx.fillStyle = gradient;
            
            // ë©”ì¸ ë¶€ë¶„
            ctx.beginPath();
            ctx.ellipse(x, y + height/2, width/2, height/2, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // ìƒë‹¨ ì—°ê²°ë¶€
            ctx.beginPath();
            ctx.ellipse(x, y, width/2, width/2, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // í•˜ë‹¨ ì—°ê²°ë¶€
            ctx.beginPath();
            ctx.ellipse(x, y + height, width/2, width/2, 0, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
    
    // ë’·ë©´ (ìœ„ìª½ ë³´ê¸°) - 3D ì¡¸ë¼ë§¨ ìŠ¤íƒ€ì¼
    function drawCharacterBack(x, y, color, walkCycle) {
        const time = Date.now() / 1000;
        
        // ë’·ë©´ ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ (ì•ë©´ê³¼ ë™ì¼í•˜ì§€ë§Œ íŒ” ì›€ì§ì„ ë°˜ëŒ€)
        const leftLegAngle = Math.sin(time * 6) * 25;
        const rightLegAngle = Math.sin(time * 6 + Math.PI) * 25;
        const leftArmAngle = Math.sin(time * 6 + Math.PI) * 15;
        const rightArmAngle = Math.sin(time * 6) * 15;
        const bodyBob = Math.abs(Math.sin(time * 12)) * 2;
        
        const moveMultiplier = walkCycle !== 0 ? 1 : 0;
        
        ctx.save();
        
        // === ë‹¤ë¦¬ (ë’¤ì—ì„œ ë´¤ì„ ë•Œ) ===
        ctx.save();
        ctx.translate(x - 6, y + 15);
        ctx.rotate((leftLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 6, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        ctx.save();
        ctx.translate(x + 6, y + 15);
        ctx.rotate((rightLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 6, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ë“± (ë’¤ì—ì„œ ë´¤ì„ ë•Œ) ===
        drawBackTorso3D(x, y - 2 - bodyBob * moveMultiplier, color);
        
        // === íŒ” (ë’¤ì—ì„œ) ===
        ctx.save();
        ctx.translate(x - 15, y - 8);
        ctx.rotate((leftArmAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 18, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        const backRightRad = (rightArmAngle * moveMultiplier * Math.PI) / 180;
        ctx.save();
        ctx.translate(x + 15, y - 8);
        ctx.rotate(backRightRad);
        drawLimb3D(0, 0, 5, 18, getDarkerColor(color), 'vertical');
        ctx.restore();

        // ì† ìœ„ì¹˜(ë’·ë©´): ì˜¤ë¥¸ì† ê¸°ì¤€ ì—…ë°ì´íŠ¸
        handAnchor.x = x + 15 + Math.sin(backRightRad) * 18;
        handAnchor.y = y - 8 + Math.cos(backRightRad) * 18;
        handAnchor.angle = backRightRad;
        handAnchor.dir = 'up';
        
        // === ë’·ë¨¸ë¦¬ ===
        drawBackHead3D(x, y - 22 - bodyBob * moveMultiplier, color);
        
        ctx.restore();
    }
    
    // ë’·ë©´ ëª¸í†µ ê·¸ë¦¬ê¸°
    function drawBackTorso3D(x, y, color) {
        // ë“± (ë” ì–´ë‘¡ê²Œ)
        const backGradient = ctx.createRadialGradient(x, y, 0, x, y, 15);
        backGradient.addColorStop(0, color);
        backGradient.addColorStop(1, getDarkerColor(color));
        
        ctx.fillStyle = backGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, 11, 15, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // ì–´ê¹¨ ë¼ì¸
        ctx.fillStyle = getEvenDarkerColor(color);
        ctx.beginPath();
        ctx.ellipse(x, y - 8, 12, 3, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ë’·ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
    function drawBackHead3D(x, y, color) {
        // ë’·ë¨¸ë¦¬ (ì–´ë‘¡ê²Œ)
        const backHeadGradient = ctx.createRadialGradient(x + 2, y - 2, 0, x, y, 12);
        backHeadGradient.addColorStop(0, color);
        backHeadGradient.addColorStop(1, getDarkerColor(color));
        
        ctx.fillStyle = backHeadGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, 12, 10, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // ë¨¸ë¦¬ì¹´ë½ ë””í…Œì¼
        ctx.fillStyle = getEvenDarkerColor(color);
        ctx.beginPath();
        ctx.ellipse(x, y - 6, 10, 3, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ì™¼ìª½ ë³´ê¸° - 3D ì¡¸ë¼ë§¨ ìŠ¤íƒ€ì¼
    function drawCharacterLeft(x, y, color, walkCycle) {
        const time = Date.now() / 1000;
        
        // ì¸¡ë©´ ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
        const frontLegAngle = Math.sin(time * 6) * 30; // ì•ë‹¤ë¦¬
        const backLegAngle = Math.sin(time * 6 + Math.PI) * 30; // ë’·ë‹¤ë¦¬
        const frontArmAngle = Math.sin(time * 6 + Math.PI) * 20; // ì•íŒ”
        const backArmAngle = Math.sin(time * 6) * 20; // ë’·íŒ”
        const bodyBob = Math.abs(Math.sin(time * 12)) * 2;
        
        const moveMultiplier = walkCycle !== 0 ? 1 : 0;
        
        ctx.save();
        
        // === ë’·ë‹¤ë¦¬ (ë¨¼ì € ê·¸ë ¤ì„œ ë’¤ì— ìœ„ì¹˜) ===
        ctx.save();
        ctx.translate(x - 3, y + 15);
        ctx.rotate((backLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 20, getEvenDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ëª¸í†µ (ì¸¡ë©´) ===
        drawSideTorso3D(x, y - 2 - bodyBob * moveMultiplier, color);
        
        // === ì•ë‹¤ë¦¬ (ìœ„ì— ê·¸ë ¤ì„œ ì•ì— ìœ„ì¹˜) ===
        ctx.save();
        ctx.translate(x + 3, y + 15);
        ctx.rotate((frontLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ì•íŒ”(ì¹´ë©”ë¼ ì¸¡, ëª¸í†µì— ë¶™ì–´ì„œ ë³´ì´ë„ë¡) ===
        ctx.save();
        const leftFrontRad = (frontArmAngle * moveMultiplier * Math.PI) / 180;
        ctx.translate(x + 6, y - 6);
        ctx.rotate(leftFrontRad);
        drawLimb3D(0, 0, 4, 18, color, 'vertical');
        ctx.restore();
        
        // ì† ìœ„ì¹˜(ì™¼ìª½ ë³´ê¸°)
        handAnchor.x = x + 6 + Math.sin(leftFrontRad) * 18;
        handAnchor.y = y - 6 + Math.cos(leftFrontRad) * 18;
        handAnchor.angle = -leftFrontRad; // íŒ”ì˜ íšŒì „ê³¼ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë¬´ê¸° íšŒì „
        handAnchor.dir = 'left';
        
        // === ë¨¸ë¦¬ (ì˜†ëª¨ìŠµ) ===
        drawSideHead3D(x, y - 22 - bodyBob * moveMultiplier, getLighterColor(color), 'left');
        
        // === ì–¼êµ´(ì™¼ìª½)
        const headY = y - 22 - bodyBob * moveMultiplier;
        drawFace(x, headY, 'left');
        
        ctx.restore();
    }
    
    // ì˜¤ë¥¸ìª½ ë³´ê¸° - 3D ì¡¸ë¼ë§¨ ìŠ¤íƒ€ì¼
    function drawCharacterRight(x, y, color, walkCycle) {
        const time = Date.now() / 1000;
        
        // ì¸¡ë©´ ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ (ì˜¤ë¥¸ìª½ì€ ì™¼ìª½ê³¼ ë¯¸ëŸ¬)
        const frontLegAngle = Math.sin(time * 6) * 30;
        const backLegAngle = Math.sin(time * 6 + Math.PI) * 30;
        const frontArmAngle = Math.sin(time * 6 + Math.PI) * 20;
        const backArmAngle = Math.sin(time * 6) * 20;
        const bodyBob = Math.abs(Math.sin(time * 12)) * 2;
        
        const moveMultiplier = walkCycle !== 0 ? 1 : 0;
        
        ctx.save();
        
        // === ë’·ë‹¤ë¦¬ ===
        ctx.save();
        ctx.translate(x + 3, y + 15);
        ctx.rotate((backLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 20, getEvenDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ëª¸í†µ (ì¸¡ë©´) ===
        drawSideTorso3D(x, y - 2 - bodyBob * moveMultiplier, color);
        
        // === ì•ë‹¤ë¦¬ ===
        ctx.save();
        ctx.translate(x - 3, y + 15);
        ctx.rotate((frontLegAngle * moveMultiplier * Math.PI) / 180);
        drawLimb3D(0, 0, 5, 20, getDarkerColor(color), 'vertical');
        ctx.restore();
        
        // === ì•íŒ”(ì¹´ë©”ë¼ ì¸¡, ëª¸í†µì— ë¶™ì–´ì„œ ë³´ì´ë„ë¡) ===
        ctx.save();
        const rightFrontRad = (frontArmAngle * moveMultiplier * Math.PI) / 180;
        ctx.translate(x - 6, y - 6);
        ctx.rotate(rightFrontRad);
        drawLimb3D(0, 0, 4, 18, color, 'vertical');
        ctx.restore();
        
        // ì† ìœ„ì¹˜(ì˜¤ë¥¸ìª½ ë³´ê¸°)
        handAnchor.x = x - 6 + Math.sin(rightFrontRad) * 18;
        handAnchor.y = y - 6 + Math.cos(rightFrontRad) * 18;
        handAnchor.angle = -rightFrontRad; // íŒ”ì˜ íšŒì „ê³¼ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë¬´ê¸° íšŒì „
        handAnchor.dir = 'right';
        
        // === ë¨¸ë¦¬ (ì˜†ëª¨ìŠµ) ===
        drawSideHead3D(x, y - 22 - bodyBob * moveMultiplier, getLighterColor(color), 'right');
        
        // === ì–¼êµ´(ì˜¤ë¥¸ìª½)
        const headY = y - 22 - bodyBob * moveMultiplier;
        drawFace(x, headY, 'right');
        
        ctx.restore();
    }
    
    // ì¸¡ë©´ ëª¸í†µ ê·¸ë¦¬ê¸°
    function drawSideTorso3D(x, y, color) {
        // ì¸¡ë©´ì—ì„œ ë³¸ ëª¸í†µ (ì¢ê²Œ)
        const sideGradient = ctx.createLinearGradient(x - 6, y, x + 6, y);
        sideGradient.addColorStop(0, getDarkerColor(color));
        sideGradient.addColorStop(0.5, color);
        sideGradient.addColorStop(1, getLighterColor(color));
        
        ctx.fillStyle = sideGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, 6, 15, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // ê°€ìŠ´ í•˜ì´ë¼ì´íŠ¸
        ctx.fillStyle = getEvenLighterColor(color);
        ctx.beginPath();
        ctx.ellipse(x + 2, y - 5, 2, 5, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ì¸¡ë©´ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
    function drawSideHead3D(x, y, color, side) {
        // ì˜†ì—ì„œ ë³¸ ë¨¸ë¦¬ (íƒ€ì›í˜•)
        const sideHeadGradient = ctx.createRadialGradient(
            side === 'left' ? x - 2 : x + 2, y - 2, 0, x, y, 10
        );
        sideHeadGradient.addColorStop(0, getEvenLighterColor(color));
        sideHeadGradient.addColorStop(0.7, color);
        sideHeadGradient.addColorStop(1, getDarkerColor(color));
        
        ctx.fillStyle = sideHeadGradient;
        ctx.beginPath();
        ctx.ellipse(x, y, 10, 9, 0, 0, 2 * Math.PI);
        ctx.fill();
        
        // 3D í•˜ì´ë¼ì´íŠ¸
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        const highlightX = side === 'left' ? x - 3 : x + 3;
        ctx.ellipse(highlightX, y - 2, 3, 4, 0, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    // ì–¼êµ´ ê·¸ë¦¬ê¸°
    function drawFace(x, y, direction) {
        if (direction === 'front') {
            // ì •ë©´ ì–¼êµ´
            // ëˆˆ
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(x - 4, y - 2, 2, 3, 0, 0, 2 * Math.PI);
            ctx.ellipse(x + 4, y - 2, 2, 3, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // ëˆˆë™ì
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(x - 4, y - 2, 1, 2, 0, 0, 2 * Math.PI);
            ctx.ellipse(x + 4, y - 2, 1, 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // ì…
            ctx.fillStyle = '#800000';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 2, 1, 0, 0, 2 * Math.PI);
            ctx.fill();
        } else if (direction === 'left' || direction === 'right') {
            // ì˜†ëª¨ìŠµ ì–¼êµ´(ë°©í–¥ì— ë§ê²Œ ë°”ê¹¥ìª½ìœ¼ë¡œ):
            // ìº”ë²„ìŠ¤ ì¢Œí‘œëŠ” +xê°€ ì˜¤ë¥¸ìª½. 
            // - ì™¼ìª½ì„ ë³¼ ë•Œ: ì–¼êµ´ ìš”ì†Œë¥¼ ë¨¸ë¦¬ì˜ ì™¼ìª½ ê°€ì¥ìë¦¬(x-ì˜¤í”„ì…‹)
            // - ì˜¤ë¥¸ìª½ì„ ë³¼ ë•Œ: ì–¼êµ´ ìš”ì†Œë¥¼ ë¨¸ë¦¬ì˜ ì˜¤ë¥¸ìª½ ê°€ì¥ìë¦¬(x+ì˜¤í”„ì…‹)
            const eyeX = direction === 'left' ? x - 8 : x + 8;
            const mouthX = direction === 'left' ? x - 9 : x + 9;
            
            // ëˆˆ (í•˜ë‚˜ë§Œ)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(eyeX, y - 2, 2, 3, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // ëˆˆë™ì
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(eyeX, y - 2, 1, 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            
            // ì…
            ctx.fillStyle = '#800000';
            ctx.beginPath();
            ctx.ellipse(mouthX, y + 3, 1, 1, 0, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
    

    
    // ìƒ‰ìƒ í—¬í¼ í•¨ìˆ˜ë“¤ (ê°„ë‹¨í•œ ë²„ì „)
    function getLighterColor(color) {
        // í°ìƒ‰ íŒ”ë ˆíŠ¸ ìš°ì„  ì ìš©
        if (color === '#FFFFFF') return '#F6F7F9';
        if (color === '#4CAF50') return '#66BB6A';
        if (color === '#2196F3') return '#42A5F5';
        return '#F0F1F4';
    }
    function getDarkerColor(color) {
        if (color === '#FFFFFF') return '#D9DEE5';
        if (color === '#4CAF50') return '#388E3C';
        if (color === '#2196F3') return '#1976D2';
        return '#9AA3B2';
    }
    function getEvenLighterColor(color) {
        if (color === '#FFFFFF') return '#FFFFFF';
        if (color === '#4CAF50') return '#81C784';
        if (color === '#2196F3') return '#64B5F6';
        return '#FFFFFF';
    }
    function getEvenDarkerColor(color) {
        if (color === '#FFFFFF') return '#B9C0CC';
        if (color === '#4CAF50') return '#2E7D32';
        if (color === '#2196F3') return '#1565C0';
        return '#70798B';
    }

    function drawActionEffects(x, y) {
        if (playerActions.isDashing) {
            // ëŒ€ì‰¬ ì´í™íŠ¸ (ì”ìƒ)
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.fillRect(x - 15, y - 25, 30, 40);
        }

        if (playerActions.isBlocking) {
            // ë°©ì–´ ì´í™íŠ¸ (ë°©íŒ¨)
            ctx.fillStyle = 'rgba(0, 100, 255, 0.6)';
            drawShield(x - 20, y - 10);
        }

        if (playerActions.isAttacking) {
            // ê³µê²© ì´í™íŠ¸ (ê²€)
            ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
            drawSword(x + 12, y - 25);
        }

        if (playerActions.isParrying) {
            // íŒ¨ë§ ì´í™íŠ¸ (ë°˜ì§ì„)
            const sparkles = 8;
            for (let i = 0; i < sparkles; i++) {
                const angle = (i / sparkles) * Math.PI * 2;
                const sparkX = x + Math.cos(angle) * 20;
                const sparkY = y + Math.sin(angle) * 20;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }

    function drawShield(x, y) {
        ctx.fillRect(x, y, 8, 20);
        ctx.fillStyle = 'rgba(150, 200, 255, 0.8)';
        ctx.fillRect(x + 1, y + 1, 6, 18);
    }

    function drawSword(x, y) {
        // ê²€ë‚ 
        ctx.fillRect(x, y, 3, 20);
        // ê²€ìë£¨
        ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
        ctx.fillRect(x - 1, y + 18, 5, 8);
    }

    // ê¸°ë³¸ ë¬´ê¸° (í•œì†ê²€) ê·¸ë¦¬ê¸° - í”Œë ˆì´ì–´ì™€ ì¼ì²´í™”
    function drawWeapon(x, y, direction = 'down') {
        // ë¬´ê¸°ê°€ ì§‘ì–´ë„£ì–´ì ¸ ìˆìœ¼ë©´ ë“±ì— ê³ ì •
        if (!playerActions.isWeaponDrawn && !playerActions.isDrawingWeapon && !playerActions.isSheathingWeapon) {
            drawSheathedWeapon(x, y, direction);
            return;
        }
        
        // ë¬´ê¸°ë¥¼ êº¼ë‚´ê±°ë‚˜ ì§‘ì–´ë„£ëŠ” ì¤‘
        if (playerActions.isDrawingWeapon || playerActions.isSheathingWeapon) {
            drawWeaponTransition(x, y, direction);
            return;
        }
        
        ctx.save();
        
        // ë°©í–¥ì— ë”°ë¥¸ ë¬´ê¸° ìœ„ì¹˜ ì„¤ì •
        let weaponX = x;
        let weaponY = y;
        let baseRotation = 0;
        const tiltDownDeg = 110; // ê¸°ë³¸ ê¸°ìš¸ê¸°

        // ì›€ì§ì„ ìƒíƒœ í™•ì¸
        const isMoving = keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight;
        
        // íŒ” ì›€ì§ì„ ê°ë„ ê³„ì‚° (ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜) - ì›€ì§ì¼ ë•Œë§Œ
        const time = Date.now() / 1000;  // ì‹œê°„ì„ ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜
        const walkCycle = isMoving ? Math.sin(time * 6) : 0;  // íŒ” ì›€ì§ì„ê³¼ ë™ì¼í•œ ì£¼ê¸° ì‚¬ìš©
        const armSwing = walkCycle * 15;
        const armRad = (armSwing * Math.PI) / 180;
        
        // ë¬´ê¸° ê¸°ë³¸ ìœ„ì¹˜ ì„¤ì • + ì›€ì§ì¼ ë•Œë§Œ íŒ” ì›€ì§ì„ ë°˜ì˜
        if (direction === 'left') {
            weaponX = x + 8 + Math.sin(armRad) * 8;
            weaponY = y + 4 + Math.cos(armRad) * 8;
            baseRotation = (tiltDownDeg * Math.PI / 180) * -1 + armRad;
        } else if (direction === 'right') {
            weaponX = x - 8 + Math.sin(armRad) * 8;
            weaponY = y + 4 + Math.cos(armRad) * 8;
            baseRotation = (tiltDownDeg * Math.PI / 180) + armRad;
        } else if (direction === 'down') {
            weaponX = x + 15;  // ì˜¤ë¥¸ì†ì— ë§ì¶° ì¡°ì •
            weaponY = y + 4 + Math.cos(armRad) * 8;
            baseRotation = (45 * Math.PI / 180) + armRad;  // 45ë„ ê¸°ìš¸ì—¬ì„œ ìì—°ìŠ¤ëŸ½ê²Œ
        } else if (direction === 'up') {
            weaponX = x + 15;  // ì˜¤ë¥¸ì†ì— ë§ì¶° ì¡°ì •
            weaponY = y + 4 + Math.cos(armRad) * 8;
            baseRotation = (-45 * Math.PI / 180) + armRad;  // -45ë„ë¡œ ê¸°ìš¸ì—¬ì„œ ë’·ëª¨ìŠµì— ë§ê²Œ
        }

        ctx.translate(weaponX, weaponY);
        ctx.rotate(baseRotation);

        if (playerActions.isAttacking) {
            drawSwordWithEffect(-4, -12, direction);
        } else {
            drawBasicSword(-2, -6, -1, -16, direction);
        }

        ctx.restore();
    }
    
    // ê¸°ë³¸ ê²€ ê·¸ë¦¬ê¸°
    function drawBasicSword(handleX, handleY, bladeX, bladeY, direction = 'down') {
        if (direction === 'up') {
            // ë’·ëª¨ìŠµì¼ ë•ŒëŠ” ì†ì¡ì´ë§Œ ë³´ì´ê²Œ
            // ê²€ìë£¨
            ctx.fillStyle = '#8B4513';  // ê°ˆìƒ‰
            ctx.fillRect(handleX, handleY, 4, 12);
            // í‚¤ìš©(ê°€ë“œ)
            ctx.fillStyle = '#A0522D';  // ì§„í•œ ê°ˆìƒ‰
            ctx.fillRect(handleX - 2, handleY - 2, 8, 4);
        } else {
            // ë‹¤ë¥¸ ë°©í–¥ì¼ ë•ŒëŠ” ê²€ë‚ ê³¼ ì†ì¡ì´ ëª¨ë‘ ë³´ì´ê²Œ
            // ê²€ìë£¨ (ì†ì¡ì´)
            ctx.fillStyle = '#8B4513';  // ê°ˆìƒ‰
            ctx.fillRect(handleX, handleY, 4, 12);
            
            // í‚¤ìš© (ê°€ë“œ)
            ctx.fillStyle = '#A0522D';  // ì§„í•œ ê°ˆìƒ‰
            ctx.fillRect(handleX - 2, handleY - 2, 8, 4);
            
            // ì¹¼ë‚  ë©”ì¸ ë¶€ë¶„
            ctx.fillStyle = '#C0C0C0';  // ì€ìƒ‰
            ctx.fillRect(handleX, handleY - 28, 4, 28);  // ë” ê¸¸ê²Œ
            
            // ì¹¼ë‚  ëë¶€ë¶„ (ë¾°ì¡±í•˜ê²Œ)
            ctx.beginPath();
            ctx.moveTo(handleX, handleY - 28);  // ì™¼ìª½ ë
            ctx.lineTo(handleX + 2, handleY - 32);  // ì¤‘ì•™ ëì 
            ctx.lineTo(handleX + 4, handleY - 28);  // ì˜¤ë¥¸ìª½ ë
            ctx.fill();
            
            // ì¹¼ë‚  í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = 0.3;
            ctx.fillRect(handleX + 1, handleY - 30, 2, 30);
            ctx.globalAlpha = 1.0;
        }
    }
    
    // ê²€ + ì´í™íŠ¸ ê·¸ë¦¬ê¸° (íœ˜ë‘ë¥´ê¸° ì‹œ)
    function drawSwordWithEffect(x, y, direction) {
        // ë°©í–¥ë³„ ê³µê²© ëª¨ì…˜
        if (direction === 'down') {
            // ì •ë©´ ê³µê²©: ìœ„ì—ì„œ ì•„ë˜ë¡œ ë‚´ë ¤ì°ê¸°
            const swingAngle = playerActions.attackSwingAngle;
            ctx.rotate((swingAngle - 45) * Math.PI / 180);  // -45ë„ì—ì„œ ì‹œì‘í•´ì„œ ì•„ë˜ë¡œ
        } else if (direction === 'up') {
            // í›„ë©´ ê³µê²©: ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë ¤ì¹˜ê¸°
            const swingAngle = playerActions.attackSwingAngle;
            ctx.rotate((swingAngle + 225) * Math.PI / 180);  // 225ë„ì—ì„œ ì‹œì‘í•´ì„œ ìœ„ë¡œ
        } else if (direction === 'left') {
            // ì™¼ìª½ ê³µê²©: ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ (ì˜¤ë¥¸ìª½ê³¼ ëŒ€ì¹­)
            const swingAngle = playerActions.attackSwingAngle;
            ctx.rotate((-swingAngle + 90) * Math.PI / 180);  // 90ë„ì—ì„œ ì‹œì‘í•´ì„œ ì™¼ìª½ìœ¼ë¡œ (ì˜¤ë¥¸ìª½ì˜ ëŒ€ì¹­)
        } else if (direction === 'right') {
            // ì˜¤ë¥¸ìª½ ê³µê²©: ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
            const swingAngle = playerActions.attackSwingAngle;
            ctx.rotate((swingAngle - 90) * Math.PI / 180);  // -90ë„ì—ì„œ ì‹œì‘í•´ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
        }
        
        // ê²€ ìì²´
        drawBasicSword(x, y, x + 1, y - 10, direction);
    }
    
    // ë“±ì— ë©”ê³  ìˆëŠ” ê²€ ê·¸ë¦¬ê¸°
    function drawSheathedWeapon(x, y, direction) {
        // ë’·ëª¨ìŠµì¼ ë•Œë§Œ ê²€ì§‘ì´ ë³´ì´ë„ë¡
        if (direction === 'up') {
            ctx.fillStyle = '#654321'; // ì–´ë‘ìš´ ê°ˆìƒ‰ (ì¹¼ì§‘)
            ctx.fillRect(x - 3, y - 12, 6, 20);
            
            ctx.fillStyle = '#8B4513'; // ê²€ìë£¨ë§Œ ì‚´ì§ ë³´ì„
            ctx.fillRect(x - 2, y - 15, 4, 5);
        }
    }
    
    // ë¬´ê¸° ì „í™˜ ì• ë‹ˆë©”ì´ì…˜
    function drawWeaponTransition(x, y, direction) {
        const progress = playerActions.weaponDrawProgress;
        
        if (playerActions.isDrawingWeapon) {
            // ë“±ì—ì„œ ì†ìœ¼ë¡œ ì´ë™
            if (direction === 'down') {
                const startX = x - 2, startY = y - 12;
                const endX = x + 18, endY = y - 5;
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(currentX, currentY, 3, 12);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(currentX + 1, currentY - 10, 1, 10);
            }
        } else if (playerActions.isSheathingWeapon) {
            // ì†ì—ì„œ ë“±ìœ¼ë¡œ ì´ë™ (ì—­ë°©í–¥)
            if (direction === 'down') {
                const startX = x + 18, startY = y - 5;
                const endX = x - 2, endY = y - 12;
                const currentX = startX + (endX - startX) * (1 - progress);
                const currentY = startY + (endY - startY) * (1 - progress);
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(currentX, currentY, 3, 12);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(currentX + 1, currentY - 10, 1, 10);
            }
        }
    }

    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
    function showDamageNumber(x, y, text, color = '#ff4444') {
        damageNumbers.push({
            x: x,
            y: y,
            text: text,
            color: color,
            startTime: Date.now(),
            duration: 1500
        });
    }

    // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸ ë° ë Œë”ë§
    function updateDamageNumbers() {
        const now = Date.now();
        
        // ë§Œë£Œëœ ìˆ«ìë“¤ ì œê±°
        damageNumbers = damageNumbers.filter(dmg => now - dmg.startTime < dmg.duration);
        
        // ë°ë¯¸ì§€ ìˆ«ìë“¤ ê·¸ë¦¬ê¸°
        damageNumbers.forEach(dmg => {
            const elapsed = now - dmg.startTime;
            const progress = elapsed / dmg.duration;
            
            // ìœ„ë¡œ ë– ì˜¤ë¥´ëŠ” ì• ë‹ˆë©”ì´ì…˜
            const offsetY = progress * -50;
            const alpha = 1 - progress;
            
            ctx.save();
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = dmg.color;
            ctx.globalAlpha = alpha;
            ctx.fillText(dmg.text, dmg.x, dmg.y + offsetY);
            ctx.restore();
        });
    }

    // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
    function isPointInCircle(px, py, cx, cy, radius) {
        const distance = Math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy));
        return distance <= radius;
    }

    // ê²Œì„ ì´ˆê¸°í™”
    function initGame() {
        canvas.style.border = '2px solid #5c67f2';
        canvas.style.borderRadius = '8px';
        canvas.style.backgroundColor = '#10181A';

        // ìˆ² ë°°ê²½ ì´ˆê¸°í™”
        initForestLayers();

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            if (e.code in keys) {
                keys[e.code] = true;
                e.preventDefault();

                // ì•¡ì…˜ ì‹¤í–‰
                handleActionInput(e.code);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code in keys) {
                keys[e.code] = false;
                e.preventDefault();

                // Sí‚¤ ë—´ë©´ ë°©ì–´ í•´ì œ
                if (e.code === 'KeyS') {
                    playerActions.isBlocking = false;
                    if (playerActions.actionState === 'blocking') {
                        playerActions.actionState = 'idle';
                    }
                }
            }
        });

        // ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (ëª¬ìŠ¤í„° ê³µê²©, ì•„ì´í…œ ìˆ˜ì§‘, í”Œë ˆì´ì–´ ê³µê²©)
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // ë“€ì–¼ ì¤‘ì´ë©´ ìƒëŒ€ë°© í´ë¦­ ê°€ëŠ¥
            if (gameState.myPlayer && gameState.myPlayer.in_duel) {
                for (const [playerId, player] of Object.entries(gameState.players)) {
                    if (playerId !== gameState.mySessionId && player.in_duel === gameState.myPlayer.in_duel) {
                        const screenPos = worldToScreen(player.x, player.y);
                        if (isPointInCircle(clickX, clickY, screenPos.x, screenPos.y, 25)) {
                            socket.emit('attack_player', { target_player_id: playerId });
                            addGameLog(`âš”ï¸ ${player.username} ê³µê²©!`, 'attack');
                            return;
                        }
                    }
                }
            }

            // ëª¬ìŠ¤í„° í´ë¦­ ì²´í¬ (ë“€ì–¼ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!gameState.myPlayer || !gameState.myPlayer.in_duel) {
                for (const [monsterId, monster] of Object.entries(gameState.monsters)) {
                    const screenPos = worldToScreen(monster.x, monster.y);
                    if (isPointInCircle(clickX, clickY, screenPos.x, screenPos.y, 35)) {
                        socket.emit('attack_monster', { monster_id: monsterId });
                        addGameLog(`ğŸ—¡ï¸ ${monster.type} ê³µê²©! ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, 'attack');
                        showDamageNumber(screenPos.x, screenPos.y, 'ë°ë¯¸ì§€!');
                        return;
                    }
                }

                // ì•„ì´í…œ í´ë¦­ ì²´í¬
                for (const [itemId, item] of Object.entries(gameState.items)) {
                    const screenPos = worldToScreen(item.x, item.y);
                    if (isPointInCircle(clickX, clickY, screenPos.x, screenPos.y, 25)) {
                        socket.emit('collect_item', { item_id: itemId });
                        return;
                    }
                }
            }
        });





        // ìƒ‰ìƒ ìœ í‹¸ë¦¬í‹° (ê°„ë‹¨í™”)
        function lightenColor(color, percent) {
            return color; // ì„ì‹œë¡œ ì›ë³¸ ìƒ‰ìƒ ë°˜í™˜
        }

        function darkenColor(color, percent) {
            return color; // ì„ì‹œë¡œ ì›ë³¸ ìƒ‰ìƒ ë°˜í™˜
        }

        // ì•¡ì…˜ ì´í™íŠ¸ ë¶„ë¦¬
        function drawActionEffects(x, y) {
            if (playerActions.isDashing) {
                // ëŒ€ì‰¬ ì´í™íŠ¸ (ì”ìƒ)
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(x - 15, y - 25, 30, 40);
            }

            if (playerActions.isBlocking) {
                // ë°©ì–´ ì´í™íŠ¸ (ë°©íŒ¨)
                ctx.fillStyle = 'rgba(0, 100, 255, 0.6)';
                drawShield(x - 20, y - 10);
            }

            if (playerActions.isAttacking) {
                // ê³µê²© ì´í™íŠ¸ (ê²€)
                ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                drawSword(x + 12, y - 25);
            }

            if (playerActions.isParrying) {
                // íŒ¨ë§ ì´í™íŠ¸ (ë°˜ì§ì„)
                const sparkles = 8;
                for (let i = 0; i < sparkles; i++) {
                    const angle = (i / sparkles) * Math.PI * 2;
                    const sparkX = x + Math.cos(angle) * 20;
                    const sparkY = y + Math.sin(angle) * 20;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        // ë°©íŒ¨ ê·¸ë¦¬ê¸°
        function drawShield(x, y) {
            ctx.fillRect(x, y, 8, 20);
            ctx.fillStyle = 'rgba(150, 200, 255, 0.8)';
            ctx.fillRect(x + 1, y + 1, 6, 18);
        }

        // ê²€ ê·¸ë¦¬ê¸°
        function drawSword(x, y) {
            // ê²€ë‚ 
            ctx.fillRect(x, y, 3, 20);
            // ê²€ìë£¨
            ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
            ctx.fillRect(x - 1, y + 18, 5, 8);
        }

        // ë“€ì–¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        document.getElementById('request-duel').addEventListener('click', () => {
            const targetUsername = document.getElementById('duel-target').value.trim();
            if (targetUsername) {
                socket.emit('request_duel', { target_username: targetUsername });
                document.getElementById('duel-target').value = '';
            }
        });

        document.getElementById('accept-duel').addEventListener('click', () => {
            if (gameState.currentDuelRequestId) {
                socket.emit('accept_duel', { request_id: gameState.currentDuelRequestId });
                document.getElementById('duel-request-modal').classList.add('hidden');
            }
        });

        document.getElementById('decline-duel').addEventListener('click', () => {
            if (gameState.currentDuelRequestId) {
                socket.emit('decline_duel', { request_id: gameState.currentDuelRequestId });
                document.getElementById('duel-request-modal').classList.add('hidden');
            }
        });

        document.getElementById('close-duel-notification').addEventListener('click', () => {
            document.getElementById('duel-notification-modal').classList.add('hidden');
        });

        // ê²Œì„ ë£¨í”„ ì‹œì‘
        gameLoop();
    }

    // ê²Œì„ ë£¨í”„
    function gameLoop() {
        const now = Date.now();
        if (now >= effects.hitstopUntil) {
            update();
        }
        render();
        requestAnimationFrame(gameLoop);
    }

    // ëª¬ìŠ¤í„° AI ì—…ë°ì´íŠ¸ (ì ë‹¹í•œ ì£¼ê¸°ë¡œ)
    setInterval(() => {
        socket.emit('monster_ai_update');
    }, 100); // 0.1ì´ˆë§ˆë‹¤ (10fps)

    // ì•¡ì…˜ ì…ë ¥ ì²˜ë¦¬
    function handleActionInput(keyCode) {
        const now = Date.now();

        switch (keyCode) {
            case 'KeyA': // ëŒ€ì‰¬
                if (!playerActions.isDashing && playerActions.dashCooldown < now) {
                    executeDash();
                }
                break;
            case 'KeyS': // ë°©ì–´
                playerActions.isBlocking = true;
                playerActions.actionState = 'blocking';
                break;
            case 'KeyD': // ê³µê²© (ê²€ íœ˜ë‘ë¥´ê¸°)
                if (!playerActions.isAttacking && playerActions.actionState === 'idle' && playerActions.isWeaponDrawn) {
                    executeSwingAttack();
                }
                break;
            case 'KeyE': // íŒ¨ë§
                if (!playerActions.isParrying && playerActions.parryCooldown < now) {
                    executeParry();
                }
                break;
            case 'KeyQ': // ë¬´ê¸° ì§‘ì–´ë„£ê¸°/êº¼ë‚´ê¸°
                if (playerActions.weaponToggleCooldown < now && !playerActions.isDrawingWeapon && !playerActions.isSheathingWeapon) {
                    toggleWeapon();
                }
                break;
            case 'KeyZ': // íŒŒë° (ì•„ì´í…œ ìˆ˜ì§‘)
                collectNearbyItems();
                break;
        }
    }

    // ëŒ€ì‰¬ ì‹¤í–‰
    function executeDash() {
        playerActions.isDashing = true;
        playerActions.actionState = 'dashing';
        playerActions.dashCooldown = Date.now() + actionTimers.dash.cooldown;

        setTimeout(() => {
            playerActions.isDashing = false;
            if (playerActions.actionState === 'dashing') {
                playerActions.actionState = 'idle';
            }
        }, actionTimers.dash.duration);

        addGameLog('ğŸ’¨ ëŒ€ì‰¬!', 'action');
    }

    // ê³µê²© ì‹¤í–‰
    // ê²€ íœ˜ë‘ë¥´ê¸° ê³µê²© ì‹¤í–‰
    function executeSwingAttack() {
        playerActions.isAttacking = true;
        playerActions.actionState = 'attacking';
        playerActions.attackSwingAngle = 0; // íœ˜ë‘ë¥´ê¸° ì‹œì‘ ê°ë„

        // ê²€ íœ˜ë‘ë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ (0ë„ì—ì„œ 120ë„ê¹Œì§€)
        const swingDuration = 300;
        const startTime = Date.now();
        
        const animateSwing = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / swingDuration, 1);
            
            // ê²€ íœ˜ë‘ë¥´ê¸° ê°ë„ (0 -> 120ë„)
            playerActions.attackSwingAngle = progress * 120;
            
            if (progress < 1) {
                requestAnimationFrame(animateSwing);
            } else {
                // ê³µê²© ì™„ë£Œ
                playerActions.isAttacking = false;
                playerActions.attackSwingAngle = 0;
                if (playerActions.actionState === 'attacking') {
                    playerActions.actionState = 'idle';
                }
            }
        };
        
        animateSwing();

        // ì£¼ë³€ ëª¬ìŠ¤í„° ì°¾ì•„ì„œ ê³µê²© (íœ˜ë‘ë¥´ê¸° ì¤‘ê°„ ì§€ì ì—ì„œ)
        setTimeout(() => {
            attackNearbyMonster();
            // íƒ€ê²©ê° ê°•í™”
            startCameraShake(4, 120);
            triggerHitstop(55);
        }, swingDuration / 2);

        addGameLog('âš”ï¸ ê²€ íœ˜ë‘ë¥´ê¸°!', 'action');
    }

    // ë¬´ê¸° í† ê¸€ (ì§‘ì–´ë„£ê¸°/êº¼ë‚´ê¸°)
    function toggleWeapon() {
        const animationDuration = 500; // 0.5ì´ˆ
        
        if (playerActions.isWeaponDrawn) {
            // ë¬´ê¸° ì§‘ì–´ë„£ê¸°
            playerActions.isSheathingWeapon = true;
            playerActions.weaponDrawProgress = 1;
            
            const sheathAnimation = () => {
                playerActions.weaponDrawProgress -= 0.05; // ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
                
                if (playerActions.weaponDrawProgress <= 0) {
                    playerActions.weaponDrawProgress = 0;
                    playerActions.isWeaponDrawn = false;
                    playerActions.isSheathingWeapon = false;
                    addGameLog('ğŸ—¡ï¸ ê²€ì„ ì§‘ì–´ë„£ì—ˆìŠµë‹ˆë‹¤', 'action');
                } else {
                    requestAnimationFrame(sheathAnimation);
                }
            };
            sheathAnimation();
            
        } else {
            // ë¬´ê¸° êº¼ë‚´ê¸°
            playerActions.isDrawingWeapon = true;
            playerActions.weaponDrawProgress = 0;
            
            const drawAnimation = () => {
                playerActions.weaponDrawProgress += 0.05; // ì ì§„ì ìœ¼ë¡œ ì¦ê°€
                
                if (playerActions.weaponDrawProgress >= 1) {
                    playerActions.weaponDrawProgress = 1;
                    playerActions.isWeaponDrawn = true;
                    playerActions.isDrawingWeapon = false;
                    addGameLog('âš”ï¸ ê²€ì„ êº¼ëƒˆìŠµë‹ˆë‹¤', 'action');
                } else {
                    requestAnimationFrame(drawAnimation);
                }
            };
            drawAnimation();
        }
        
        playerActions.weaponToggleCooldown = Date.now() + 600; // 0.6ì´ˆ ì¿¨ë‹¤ìš´
    }

    // ì£¼ë³€ ëª¬ìŠ¤í„° ê³µê²©
    function attackNearbyMonster() {
        if (!gameState.myPlayer) return;

        const playerX = gameState.myPlayer.x;
        const playerY = gameState.myPlayer.y;
        const attackRange = 50; // ê³µê²© ë²”ìœ„ (ì¶•ì†Œ)
        let targetFound = false;

        // ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
        let closestMonster = null;
        let closestDistance = attackRange;

        for (const [monsterId, monster] of Object.entries(gameState.monsters)) {
            const distance = Math.sqrt(
                Math.pow(monster.x - playerX, 2) + Math.pow(monster.y - playerY, 2)
            );

            if (distance <= attackRange && distance < closestDistance) {
                closestMonster = { id: monsterId, monster: monster };
                closestDistance = distance;
                targetFound = true;
            }
        }

        // ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ê³µê²©
        if (targetFound && closestMonster) {
            socket.emit('attack_monster', { monster_id: closestMonster.id });
            addGameLog(`ğŸ—¡ï¸ ${closestMonster.monster.type} ê³µê²©! ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, 'attack');
            
            // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
            const screenPos = worldToScreen(closestMonster.monster.x, closestMonster.monster.y);
            showDamageNumber(screenPos.x, screenPos.y, 'íƒ€ê²©!', '#ffaa00');
        } else {
            addGameLog('ğŸš« ê³µê²© ë²”ìœ„ì— ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤!', 'info');
        }
    }

    // íŒ¨ë§ ì‹¤í–‰
    function executeParry() {
        playerActions.isParrying = true;
        playerActions.actionState = 'parrying';
        playerActions.parryCooldown = Date.now() + actionTimers.parry.cooldown;

        setTimeout(() => {
            playerActions.isParrying = false;
            if (playerActions.actionState === 'parrying') {
                playerActions.actionState = 'idle';
            }
        }, actionTimers.parry.duration);

        addGameLog('ğŸ›¡ï¸ íŒ¨ë§!', 'action');
    }

    // íŒŒë° (ì£¼ë³€ ì•„ì´í…œ ìˆ˜ì§‘)
    function collectNearbyItems() {
        if (!gameState.myPlayer) return;

        const playerX = gameState.myPlayer.x;
        const playerY = gameState.myPlayer.y;
        const collectRange = 100; // ìˆ˜ì§‘ ë²”ìœ„
        let itemsCollected = 0;

        // ì£¼ë³€ ì•„ì´í…œë“¤ í™•ì¸
        for (const [itemId, item] of Object.entries(gameState.items)) {
            const distance = Math.sqrt(
                Math.pow(item.x - playerX, 2) + Math.pow(item.y - playerY, 2)
            );

            // ë²”ìœ„ ë‚´ ì•„ì´í…œ ìˆ˜ì§‘
            if (distance <= collectRange) {
                socket.emit('collect_item', { item_id: itemId });
                itemsCollected++;
            }
        }

        if (itemsCollected > 0) {
            addGameLog(`ğŸ’° ${itemsCollected}ê°œ ì•„ì´í…œ ìˆ˜ì§‘ ì™„ë£Œ!`, 'success');
        } else {
            addGameLog('ğŸ“­ ì£¼ë³€ì— ìˆ˜ì§‘í•  ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.', 'info');
        }
    }

    // ê²Œì„ ì—…ë°ì´íŠ¸
    function update() {
        if (!gameState.myPlayer) return;

        let moved = false;
        let moveSpeed = 3;
        if (playerActions.isDashing) {
            moveSpeed = 8; // ëŒ€ì‰¬ ì¤‘ì—ëŠ” ì´ë™ ì†ë„ ì¦ê°€
        } else if (playerActions.isBlocking) {
            moveSpeed = 1; // ë°©ì–´ ì¤‘ì—ëŠ” ì´ë™ ì†ë„ ê°ì†Œ
        } else if (playerActions.isAttacking || playerActions.isParrying) {
            moveSpeed = 0.5; // ê³µê²© ë˜ëŠ” íŒ¨ë§ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
        }


        // ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ ë”°ë¼ê°€ê¸° (ë¶€ë“œëŸ½ê²Œ)
        if (gameState.myPlayer) {
            camera.targetX = gameState.myPlayer.x;
            camera.targetY = gameState.myPlayer.y;

            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;
        }
        let newX = gameState.myPlayer.x;
        let newY = gameState.myPlayer.y;

        // ì´ë™ ì²˜ë¦¬ (ë°©í–¥í‚¤ë§Œ)
        if (keys['ArrowUp']) {
            newY = Math.max(25, newY - moveSpeed);
            moved = true;
            gameState.playerDirection = 'up'; // ìœ„ìª½ì„ ë³´ê³  ìˆìŒ
        }
        if (keys['ArrowDown']) {
            newY = Math.min(canvas.height - 25, newY + moveSpeed);
            moved = true;
            gameState.playerDirection = 'down'; // ì•„ë˜ìª½ì„ ë³´ê³  ìˆìŒ
        }
        if (keys['ArrowLeft']) {
            newX = Math.max(25, newX - moveSpeed);
            moved = true;
            gameState.playerDirection = 'left'; // ì™¼ìª½ì„ ë³´ê³  ìˆìŒ
        }
        if (keys['ArrowRight']) {
            newX = Math.min(canvas.width - 25, newX + moveSpeed);
            moved = true;
            gameState.playerDirection = 'right'; // ì˜¤ë¥¸ìª½ì„ ë³´ê³  ìˆìŒ
        }

        if (moved) {
            gameState.myPlayer.x = newX;
            gameState.myPlayer.y = newY;
            socket.emit('player_move', { x: newX, y: newY });
        }
    }

    // ë Œë”ë§
    function render() {
        // ì¹´ë©”ë¼ ì…°ì´í¬ ì ìš©
        let shakeX = 0, shakeY = 0;
        if (effects.cameraShake.amp > 0) {
            const progress = (Date.now() - effects.cameraShake.start) / effects.cameraShake.duration;
            if (progress >= 1) {
                effects.cameraShake.amp = 0;
            } else {
                shakeX = (Math.random() * 2 - 1) * effects.cameraShake.amp;
                shakeY = (Math.random() * 2 - 1) * effects.cameraShake.amp;
                effects.cameraShake.amp *= effects.cameraShake.decay;
            }
        }

        ctx.save();
        ctx.translate(shakeX, shakeY);

        // ìˆ² ë°°ê²½ ê·¸ë¦¬ê¸°
        drawForestBackground();

        // ì•„ì´í…œ ë Œë”ë§
        for (const [itemId, item] of Object.entries(gameState.items)) {
            drawItem(item);
        }

        // ëª¬ìŠ¤í„° ë Œë”ë§
        for (const [monsterId, monster] of Object.entries(gameState.monsters)) {
            drawMonster(monster);
        }

        // í”Œë ˆì´ì–´ë“¤ ë Œë”ë§
        for (const [sessionId, player] of Object.entries(gameState.players)) {
            drawPlayer(player, sessionId === gameState.mySessionId);
            

        }

        // ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
        updateDamageNumbers();

        ctx.restore();
    }

    // ìˆ² ë°°ê²½ ìƒì„±
    function initForestLayers() {
        // ì›ê±°ë¦¬ ë‚˜ë¬´
        forest.far = [];
        for (let i = -200; i < canvas.width + 200; i += 80) {
            forest.far.push({ x: i + Math.random() * 30, h: 90 + Math.random() * 30 });
        }
        // ì¤‘ê±°ë¦¬ ë‚˜ë¬´
        forest.mid = [];
        for (let i = -200; i < canvas.width + 200; i += 120) {
            forest.mid.push({ x: i + Math.random() * 40, h: 130 + Math.random() * 40 });
        }
        // ë‚™ì—½ ì´ˆê¸°í™”
        forest.leaves = [];
    }

    function drawForestBackground() {
        // ìºë…¸í”¼ ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
        const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bg.addColorStop(0, '#0F2F2E');
        bg.addColorStop(1, '#132B2A');
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ì›ê±°ë¦¬ ë ˆì´ì–´(ëŠë¦° íŒŒë¼ë™ìŠ¤)
        ctx.fillStyle = 'rgba(14,31,32,0.6)';
        forest.far.forEach(t => {
            const px = ((t.x - camera.x * 0.2) % (canvas.width + 200)) - 100;
            drawTreeSilhouette(px, canvas.height - 80, t.h, 0.6);
        });
        // ì¤‘ê±°ë¦¬ ë ˆì´ì–´
        ctx.fillStyle = 'rgba(20,52,52,0.85)';
        forest.mid.forEach(t => {
            const px = ((t.x - camera.x * 0.35) % (canvas.width + 240)) - 120;
            drawTreeSilhouette(px, canvas.height - 60, t.h, 0.9);
        });

        // ì§€ë©´ í…ìŠ¤ì²˜ ë„íŠ¸
        ctx.fillStyle = 'rgba(45,84,67,0.5)';
        for (let i = 0; i < 80; i++) {
            const x = (i * 13 + (camera.x * 0.1)) % canvas.width;
            const y = canvas.height - 40 + (i * 7 % 40);
            ctx.fillRect(x, y, 2, 2);
        }

        // ë‚™ì—½ ì—…ë°ì´íŠ¸/ë“œë¡œìš°
        updateLeaves();
        forest.leaves.forEach(l => {
            ctx.fillStyle = l.color;
            ctx.beginPath();
            ctx.ellipse(l.x, l.y, 3, 2, l.rot, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawTreeSilhouette(x, baseY, h, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        // íŠ¸ë í¬
        ctx.fillRect(x - 3, baseY - h, 6, h);
        // ìºë…¸í”¼
        ctx.beginPath();
        ctx.ellipse(x, baseY - h, 28, 18, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(x - 15, baseY - h + 10, 20, 14, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(x + 15, baseY - h + 8, 22, 16, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
    }

    function updateLeaves() {
        // ìŠ¤í°
        if (forest.leaves.length < 10 && Math.random() < 0.2) {
            forest.leaves.push({
                x: Math.random() * canvas.width,
                y: -10,
                vy: 20 + Math.random() * 20,
                rot: Math.random() * Math.PI,
                color: Math.random() < 0.5 ? 'rgba(82,140,96,0.8)' : 'rgba(196,176,80,0.8)'
            });
        }
        const dt = 1/60;
        forest.leaves.forEach(l => {
            l.y += l.vy * dt;
            l.x += Math.sin(l.y * 0.05) * 0.6;
            l.rot += 0.03;
        });
        forest.leaves = forest.leaves.filter(l => l.y < canvas.height);
    }

    // ì¹´ë©”ë¼ ì…°ì´í¬/íˆíŠ¸ìŠ¤í†± ìœ í‹¸
    function startCameraShake(amp = 4, duration = 120) {
        effects.cameraShake = { amp, duration, start: Date.now(), decay: 0.85 };
    }
    function triggerHitstop(ms = 55) {
        effects.hitstopUntil = Math.max(effects.hitstopUntil, Date.now() + ms);
    }

    // ê²©ì ê·¸ë¦¬ê¸°
    function drawGrid() {
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 0.5;

        for (let x = 0; x < canvas.width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        for (let y = 0; y < canvas.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }

    function drawEnhancedGrid() {
        const gridSize = 50;
        const offsetX = (camera.x % gridSize);
        const offsetY = (camera.y % gridSize);
        
        // ì£¼ ê²©ìì„ 
        ctx.strokeStyle = 'rgba(74, 85, 104, 0.3)';
        ctx.lineWidth = 1;

        for (let x = -offsetX; x < canvas.width + gridSize; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        for (let y = -offsetY; y < canvas.height + gridSize; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // ë³´ì¡° ê²©ìì„  (ë” ì„¸ë°€í•˜ê²Œ)
        const smallGridSize = 25;
        const smallOffsetX = (camera.x % smallGridSize);
        const smallOffsetY = (camera.y % smallGridSize);
        
        ctx.strokeStyle = 'rgba(74, 85, 104, 0.1)';
        ctx.lineWidth = 0.5;

        for (let x = -smallOffsetX; x < canvas.width + smallGridSize; x += smallGridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        for (let y = -smallOffsetY; y < canvas.height + smallGridSize; y += smallGridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }

    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° (3/4 ë·°)
    function drawPlayer(player, isMe) {
        const screenX = worldToScreen(player.x, player.y).x;
        const screenY = worldToScreen(player.x, player.y).y;

        // ì´ë™ ìƒíƒœ í™•ì¸ (í‚¤ê°€ ëˆŒë ¤ìˆìœ¼ë©´ ì›€ì§ì´ëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼)
        const isMoving = isMe && (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight);
        
        // ìºë¦­í„° ëª¸ì²´ (ì…ì²´ íš¨ê³¼ + ì• ë‹ˆë©”ì´ì…˜) - í°ìƒ‰ íŒ”ë ˆíŠ¸ í†µì¼
        ctx.fillStyle = '#FFFFFF';
        const direction = isMe ? gameState.playerDirection : 'down';
        drawIsometric3DCharacter(screenX, screenY, '#FFFFFF', isMoving, direction);

        // í”Œë ˆì´ì–´ ì´ë¦„ (ë“€ì–¼ ì¤‘ì´ë©´ ë¹¨ê°„ìƒ‰)
        ctx.fillStyle = player.in_duel ? '#FF4444' : '#FFFFFF';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(player.username, screenX, screenY - 25);

        // ë ˆë²¨ í‘œì‹œ
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(`Lv.${player.level}`, screenX, screenY + 35);
        
        // ë“€ì–¼ ì¤‘ í‘œì‹œ
        if (player.in_duel) {
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('âš”ï¸ DUEL', screenX, screenY - 40);
        }

        // HP ë°”
        const barWidth = 30;
        const barHeight = 4;
        const hpPercent = player.hp / 100;

        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenX - barWidth / 2, screenY + 25, barWidth, barHeight);
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(screenX - barWidth / 2, screenY + 25, barWidth * hpPercent, barHeight);
    }

    // ëª¬ìŠ¤í„° ê·¸ë¦¬ê¸° (3/4 ë·°)
    function drawMonster(monster) {
        const screenPos = worldToScreen(monster.x, monster.y);
        const isBoss = monster.monster_type === 'boss';
        const size = isBoss ? 35 : 25;

        // ëª¬ìŠ¤í„° ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(screenPos.x, screenPos.y + size + 5, size, 8, 0, 0, 2 * Math.PI);
        ctx.fill();

        // ë³´ìŠ¤ íŠ¹ë³„ íš¨ê³¼
        if (isBoss) {
            const time = Date.now() / 1000;
            const auraSize = size + Math.sin(time * 3) * 8;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, auraSize, 0, 2 * Math.PI);
            ctx.fill();
        }

        // ê°„ë‹¨í•œ ëª¬ìŠ¤í„° (ì›í˜•)
        let bodyColor;
        if (monster.type === 'ğŸ‘¹') {
            bodyColor = '#8B0000'; // ì–´ë‘ìš´ ë¹¨ê°•
        } else if (monster.type === 'ğŸ‘¾') {
            bodyColor = '#4B0082'; // ë³´ë¼ìƒ‰
        } else if (monster.type === 'ğŸ¤–') {
            bodyColor = '#708090'; // íšŒìƒ‰
        } else if (isBoss) {
            bodyColor = '#8B0000'; // ë³´ìŠ¤ëŠ” ì§„í•œ ë¹¨ê°•
        }

        // ëª¬ìŠ¤í„° ëª¸ì²´ (ì›í˜•)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, size/2, 0, 2 * Math.PI);
        ctx.fill();
        
        // ëˆˆ (ë¹¨ê°„ ì )
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(screenPos.x - 5, screenPos.y - 5, 2, 0, 2 * Math.PI);
        ctx.arc(screenPos.x + 5, screenPos.y - 5, 2, 0, 2 * Math.PI);
        ctx.fill();
        // ê·¸ë¦¼ì íš¨ê³¼ ë¦¬ì…‹
        ctx.shadowBlur = 0;

        // HP ë°” (ë³´ìŠ¤ëŠ” ë” í° HPë°”)
        const barWidth = isBoss ? 80 : 40;
        const barHeight = isBoss ? 8 : 6;
        const hpPercent = monster.hp / monster.max_hp;

        ctx.fillStyle = '#FF0000';
        ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - (isBoss ? 35 : 25), barWidth, barHeight);
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - (isBoss ? 35 : 25), barWidth * hpPercent, barHeight);

        // HP í…ìŠ¤íŠ¸
        ctx.fillStyle = '#FFFFFF';
        ctx.font = isBoss ? '12px Arial' : '10px Arial';
        ctx.fillText(`${monster.hp}/${monster.max_hp}`, screenPos.x, screenPos.y - (isBoss ? 40 : 30));
        
        // ë³´ìŠ¤ íƒ€ì´í‹€
        if (isBoss) {
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('ğŸ”¥ BOSS ğŸ”¥', screenPos.x, screenPos.y - 55);
        }
        

    }


    function drawItem(item) {
        const screenPos = worldToScreen(item.x, item.y);

        ctx.font = '25px Arial';
        ctx.textAlign = 'center';

        // ë°˜ì§ì´ëŠ” íš¨ê³¼
        const time = Date.now() / 1000;
        const alpha = 0.7 + 0.3 * Math.sin(time * 3);
        const bounce = Math.sin(time * 4) * 3; // ìœ„ì•„ë˜ í”ë“¤ë¦¼

        ctx.globalAlpha = alpha;
        ctx.fillText(item.type, screenPos.x, screenPos.y + bounce);

        ctx.globalAlpha = 1;
    }

    // ì ê³¼ ì›ì˜ ì¶©ëŒ ì²´í¬
    function isPointInCircle(px, py, cx, cy, radius) {
        const dx = px - cx;
        const dy = py - cy;
        return (dx * dx + dy * dy) <= (radius * radius);
    }

    // ê²Œì„ ë¡œê·¸ ì¶”ê°€
    function addGameLog(message, type = 'info') {
        const gameLog = document.getElementById('game-log');
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${type}`;
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

        gameLog.appendChild(logEntry);
        gameLog.scrollTop = gameLog.scrollHeight;

        // ìµœëŒ€ 50ê°œ ë¡œê·¸ë§Œ ìœ ì§€
        while (gameLog.children.length > 50) {
            gameLog.removeChild(gameLog.firstChild);
        }
    }

    // ì±„íŒ… ë©”ì‹œì§€ ì¶”ê°€
    function addChatMessage(username, message) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';
        messageDiv.innerHTML = `<strong>${username}:</strong> ${message}`;

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // ìµœëŒ€ 100ê°œ ë©”ì‹œì§€ë§Œ ìœ ì§€
        while (chatMessages.children.length > 100) {
            chatMessages.removeChild(chatMessages.firstChild);
        }
    }

    // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
    function updatePlayerInfo(data) {
        if (data.level) playerInfoElements.level.textContent = data.level;
        if (data.exp !== undefined) {
            playerInfoElements.exp.textContent = data.exp;
            playerInfoElements.expNeeded.textContent = data.level * 100;
        }
        if (data.hp) playerInfoElements.hp.textContent = data.hp;
        if (data.score) playerInfoElements.score.textContent = data.score;
        if (data.tickets) playerInfoElements.tickets.textContent = data.tickets;
    }

    // Socket.IO ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
    socket.on('connect', () => {
        addGameLog('ğŸŒ ê²Œì„ ì„œë²„ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
        gameState.mySessionId = socket.id;
    });

    socket.on('game_state', (data) => {
        gameState.players = data.players;
        gameState.monsters = data.monsters;
        gameState.items = data.items;
        gameState.duels = data.duels || {};

        if (gameState.mySessionId && data.players[gameState.mySessionId]) {
            gameState.myPlayer = data.players[gameState.mySessionId];
        }

        addGameLog(`ğŸ® ê²Œì„ ìƒíƒœ ë¡œë“œë¨ - í”Œë ˆì´ì–´: ${Object.keys(data.players).length}, ëª¬ìŠ¤í„°: ${Object.keys(data.monsters).length}`, 'info');
    });

    socket.on('player_joined', (data) => {
        gameState.players[data.session_id] = data.player;
        addGameLog(`ğŸ‘‹ ${data.player.username}ë‹˜ì´ ê²Œì„ì— ì°¸ì—¬í–ˆìŠµë‹ˆë‹¤!`, 'join');
    });

    socket.on('player_left', (data) => {
        if (gameState.players[data.session_id]) {
            addGameLog(`ğŸ‘‹ ${gameState.players[data.session_id].username}ë‹˜ì´ ê²Œì„ì„ ë– ë‚¬ìŠµë‹ˆë‹¤.`, 'leave');
            delete gameState.players[data.session_id];
        }
    });

    socket.on('player_moved', (data) => {
        if (gameState.players[data.session_id]) {
            gameState.players[data.session_id].x = data.x;
            gameState.players[data.session_id].y = data.y;
        }
    });

    socket.on('monster_damaged', (data) => {
        if (gameState.monsters[data.monster_id]) {
            gameState.monsters[data.monster_id].hp = data.hp;
            addGameLog(`ğŸ’¥ ëª¬ìŠ¤í„°ê°€ ${data.damage} ë°ë¯¸ì§€ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤!`, 'combat');
            
            // ëª¬ìŠ¤í„° ìœ„ì¹˜ì— ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
            const monster = gameState.monsters[data.monster_id];
            const screenPos = worldToScreen(monster.x, monster.y);
            showDamageNumber(screenPos.x, screenPos.y, `-${data.damage}`, '#ff4444');
        }
    });

    socket.on('monster_killed', (data) => {
        delete gameState.monsters[data.monster_id];
        addGameLog(`âš”ï¸ ${data.killer}ë‹˜ì´ ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤! (+${data.exp_gained} EXP, +${data.score_gained} ì ìˆ˜)`, 'success');

        if (data.killer === "{{ session.username }}") {
            // ë‚´ê°€ ì²˜ì¹˜í•œ ê²½ìš° UI ì—…ë°ì´íŠ¸
            const currentScore = parseInt(playerInfoElements.score.textContent);
            playerInfoElements.score.textContent = currentScore + data.score_gained;
        }
    });

    socket.on('item_collected', (data) => {
        delete gameState.items[data.item_id];
        addGameLog(`âœ¨ ${data.collector}ë‹˜ì´ ${data.item_type} ì•„ì´í…œì„ íšë“í–ˆìŠµë‹ˆë‹¤! (+${data.score_bonus} ì ìˆ˜)`, 'success');

        if (data.collector === "{{ session.username }}") {
            // ë‚´ê°€ íšë“í•œ ê²½ìš° UI ì—…ë°ì´íŠ¸
            const currentScore = parseInt(playerInfoElements.score.textContent);
            playerInfoElements.score.textContent = currentScore + data.score_bonus;
        }
    });

    socket.on('level_up', (data) => {
        const modal = document.getElementById('levelup-modal');
        const newLevelDisplay = document.getElementById('new-level-display');

        newLevelDisplay.textContent = data.new_level;
        modal.classList.remove('hidden');

        updatePlayerInfo({
            level: data.new_level,
            exp: 0,
            hp: 100
        });

        addGameLog(`ğŸ‰ ë ˆë²¨ì—…! ë ˆë²¨ ${data.new_level}ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
    });

    socket.on('chat_message', (data) => {
        addChatMessage(data.username, data.message);
    });

    socket.on('disconnect', () => {
        addGameLog('âŒ ì„œë²„ì™€ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.', 'error');
    });

    // UI ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
    document.getElementById('close-levelup').addEventListener('click', () => {
        document.getElementById('levelup-modal').classList.add('hidden');
    });

    document.getElementById('send-chat').addEventListener('click', () => {
        const chatInput = document.getElementById('chat-input');
        const message = chatInput.value.trim();

        if (message) {
            socket.emit('chat_message', { message: message });
            chatInput.value = '';
        }
    });

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('send-chat').click();
        }
    });

    document.getElementById('enter-dungeon').addEventListener('click', () => {
        const tickets = parseInt(playerInfoElements.tickets.textContent);
        if (tickets >= 3) {
            // ë˜ì „ ì…ì¥ ë¡œì§ (í–¥í›„ êµ¬í˜„)
            const modal = document.getElementById('dungeon-modal');
            modal.classList.remove('hidden');

            setTimeout(() => {
                modal.classList.add('hidden');
                addGameLog('ğŸ° ë˜ì „ ê¸°ëŠ¥ì€ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', 'info');
            }, 3000);
        } else {
            addGameLog('âŒ ë˜ì „ ì…ì¥ì—ëŠ” í‹°ì¼“ 3ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤!', 'error');
        }
    });

    // ë“€ì–¼ ê´€ë ¨ ì†Œì¼“ ì´ë²¤íŠ¸ë“¤
    socket.on('duel_request_sent', (data) => {
        addGameLog(`âš”ï¸ ${data.target_username}ë‹˜ì—ê²Œ ë“€ì–¼ ì‹ ì²­ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`, 'duel');
    });

    socket.on('duel_request_received', (data) => {
        gameState.currentDuelRequestId = data.request_id;
        document.getElementById('duel-request-message').textContent = 
            `${data.from_username}ë‹˜ì´ ë“€ì–¼ì„ ì‹ ì²­í–ˆìŠµë‹ˆë‹¤!`;
        document.getElementById('duel-request-modal').classList.remove('hidden');
        addGameLog(`âš”ï¸ ${data.from_username}ë‹˜ì—ê²Œì„œ ë“€ì–¼ ì‹ ì²­ì´ ì™”ìŠµë‹ˆë‹¤!`, 'duel');
    });

    socket.on('duel_started', (data) => {
        addGameLog(`âš”ï¸ ${data.opponent}ë‹˜ê³¼ ë“€ì–¼ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'duel');
        showDuelNotification('ë“€ì–¼ ì‹œì‘!', `${data.opponent}ë‹˜ê³¼ 1:1 ì „íˆ¬ê°€ ì‹œì‘ë©ë‹ˆë‹¤!`);
    });

    socket.on('duel_ended', (data) => {
        if (data.result === 'victory') {
            addGameLog(`ğŸ† ${data.loser}ë‹˜ê³¼ì˜ ë“€ì–¼ì—ì„œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! (+50ì )`, 'victory');
            showDuelNotification('ìŠ¹ë¦¬!', `${data.loser}ë‹˜ê³¼ì˜ ë“€ì–¼ì—ì„œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`);
        } else {
            addGameLog(`ğŸ’€ ${data.winner}ë‹˜ê³¼ì˜ ë“€ì–¼ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.`, 'defeat');
            showDuelNotification('íŒ¨ë°°...', `${data.winner}ë‹˜ê³¼ì˜ ë“€ì–¼ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.`);
        }
    });

    socket.on('duel_declined', (data) => {
        addGameLog(`ğŸ˜” ${data.from_username}ë‹˜ì´ ë“€ì–¼ ì‹ ì²­ì„ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤.`, 'info');
    });

    socket.on('duel_error', (data) => {
        addGameLog(`âŒ ë“€ì–¼ ì˜¤ë¥˜: ${data.message}`, 'error');
    });

    socket.on('player_damaged', (data) => {
        addGameLog(`ğŸ’¥ ${data.attacker}ë‹˜ì´ ${data.target}ë‹˜ì—ê²Œ ${data.damage} ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, 'combat');
    });

    socket.on('player_damaged_by_monster', (data) => {
        addGameLog(`ğŸ‘¹ ${data.monster_type} ëª¬ìŠ¤í„°ê°€ í”Œë ˆì´ì–´ì—ê²Œ ${data.damage} ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, 'combat');
        
        // ë‚´ê°€ ê³µê²©ë‹¹í–ˆë‹¤ë©´ ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
        if (data.player_id === gameState.mySessionId && gameState.myPlayer) {
            const screenPos = worldToScreen(gameState.myPlayer.x, gameState.myPlayer.y);
            showDamageNumber(screenPos.x, screenPos.y, `-${data.damage}`, '#ff0000');
            
            // HP ì—…ë°ì´íŠ¸
            gameState.myPlayer.hp = data.hp;
            updatePlayerInfo({ hp: data.hp });
            
            // HPê°€ 0ì´ ë˜ë©´ ì‚¬ë§ ì²˜ë¦¬
            if (data.hp <= 0) {
                addGameLog('ğŸ’€ ë‹¹ì‹ ì´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤! HPê°€ ìë™ìœ¼ë¡œ íšŒë³µë©ë‹ˆë‹¤.', 'defeat');
                setTimeout(() => {
                    gameState.myPlayer.hp = 100;
                    updatePlayerInfo({ hp: 100 });
                    addGameLog('ğŸ’š HPê°€ ì™„ì „íˆ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                }, 3000);
            }
        }
    });

    // ë“€ì–¼ ì•Œë¦¼ ëª¨ë‹¬ í‘œì‹œ í•¨ìˆ˜
    function showDuelNotification(title, message) {
        document.getElementById('duel-notification-title').textContent = title;
        document.getElementById('duel-notification-message').textContent = message;
        document.getElementById('duel-notification-modal').classList.remove('hidden');
    }

    // ê²Œì„ ì‹œì‘
    window.addEventListener('load', initGame);
</script>
{% endblock %}